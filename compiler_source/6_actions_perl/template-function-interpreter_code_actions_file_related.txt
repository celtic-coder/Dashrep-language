# no-space dashes-long-line  <new_line>
# dashrep_file_actions  <new_line>
<new_line>

sub dashrep_file_actions  <new_line>
{  <new_line>
    my $source_definitions ;  <new_line>
    my $action_name ;  <new_line>
    my $operand_one ;  <new_line>
    my $operand_two ;  <new_line>
    my $operand_three ;  <new_line>
    my $operand_four ;  <new_line>
    my $operand_five ;  <new_line>
    my $operands_all ;  <new_line>
    my $action_result ;  <new_line>
    my $translation ;  <new_line>
    my $partial_translation ;  <new_line>
    my $source_filename ;  <new_line>
    my $target_filename ;  <new_line>
    my $source_phrase_name ;  <new_line>
    my $target_phrase_name ;  <new_line>
    my $line_count ;  <new_line>
    my $possible_error_message ;  <new_line>
    my $all_defs_begin ;  <new_line>
    my $all_defs_end ;  <new_line>
    my $phrase_begin ;  <new_line>
    my $phrase_end ;  <new_line>
    my $def_begin ;  <new_line>
    my $def_end ;  <new_line>
    my $all_lines ;  <new_line>
    my $input_line ;  <new_line>
    my $phrase_name ;  <new_line>
    my $numeric_return_value ;  <new_line>
    my $counter ;  <new_line>
    my $definitions_or_phrase_names ;  <new_line>
    my $string_to_find ;  <new_line>
    my $length_of_string ;  <new_line>
    my $sequence_of_phrases ;  <new_line>
    my $directory ;  <new_line>
    my $file_name ;  <new_line>
    my $list_of_file_names ;  <new_line>
    my $read_time ;  <new_line>
    my $write_time ;  <new_line>
    my $file_size ;  <new_line>
    my $number_of_column_names ;  <new_line>
    my $use_two_spaces_as_delimiter ;  <new_line>
    my $text_item_in_column ;  <new_line>
    my $number_of_columns ;  <new_line>
    my $column_pointer ;  <new_line>
    my $unique_value ;  <new_line>
    my $phrase_naming_convention_for_this_column ;  <new_line>
    my $line_ending ;  <new_line>
    my $line_number ;  <new_line>
    my $full_path ;  <new_line>
    my $temp_text ;  <new_line>
    my $list_name_prefix ;  <new_line>
    my $list_of_words ;  <new_line>
    my $word ;  <new_line>
    my $matching_text ;  <new_line>
    my $possible_match ;  <new_line>
    my $storage_name ;  <new_line>
    my $words_to_match ;  <new_line>
    my $length_of_first_word ;  <new_line>
    my $second_word ;  <new_line>
    my $name_of_phrase_that_contains_list_of_index_values ;  <new_line>
    my $first_word ;  <new_line>
    my $entry_begin ;  <new_line>
    my $entry_end ;  <new_line>
    my $entry_unique ;  <new_line>
    my $list_of_unique_values ;  <new_line>
    my $found_unique_value ;  <new_line>
    my $line_status ;  <new_line>
    my $tag_name ;  <new_line>
    my $multiline_value_name ;  <new_line>
    my $remainder_of_line ;  <new_line>
    my $prefix_text ;  <new_line>
    my $target_sub_folder ;  <new_line>
    my $slash_or_backslash_for_path ;  <new_line>
    my $accumulated_matching_entry_info ;  <new_line>
    my $entry_delete ;  <new_line>
    my $entry_matching_id ;  <new_line>
    my $possible_matching_entry_info ;  <new_line>
    my $pointer ;  <new_line>
    my $list_of_storage_names ;  <new_line>
    my $list_of_words_as_text ;  <new_line>
    my $accumulated_text ;  <new_line>
    my $minimum_number_of_columns ;  <new_line>
    my @list_of_values_in_column ;  <new_line>
    my @value_in_column ;  <new_line>
    my @list_of_tag_values_in_sequence_encountered ;  <new_line>
    my @list_of_tag_names ;  <new_line>
    my @list_of_phrases ;  <new_line>
    my @phrase_naming_convention_for_column ;  <new_line>
    my %exists_tag_name ;  <new_line>
    my %content_for_tag ;  <new_line>


# no-space dashes-long-line  <new_line>
#  Initialization.  <new_line>

    $possible_error_message = "" ;  <new_line>
    $action_result = " " ;  <new_line>


# no-space dashes-long-line  <new_line>
#  Verify that there are no function operands.  <new_line>

    if ( scalar( @_ ) != 0 )  <new_line>
    {  <new_line>
        warn "Warning: Call to File-related action subroutine does not have zero parameters." ;  <new_line>
        return 0 ;  <new_line>
    }  <new_line>


# no-space dashes-long-line  <new_line>
#  Get the inputs.  <new_line>
#  Use local copies of the operands so that  <new_line>
#  this subroutine can be called recursively.  <new_line>

    $action_name = $global_action_name ;  <new_line>
    $operand_one = $global_operand_one ;  <new_line>
    $operand_two = $global_operand_two ;  <new_line>
    $operand_three = $global_operand_three ;  <new_line>
    $operand_four = $global_operand_four ;  <new_line>
    $operand_five = $global_operand_five ;  <new_line>
    $operands_all = $global_operands_all ;  <new_line>


# no-space dashes-long-line  <new_line>
#  Specify the default output (the action result).  <new_line>

    $action_result = " " ;  <new_line>


# no-space dashes-long-line  <new_line>
#  Define filename variables and phrase name  <new_line>
#  variables based on the contents of the  <new_line>
#  operands.  <new_line>

    $source_phrase_name = $operand_one ;  <new_line>
    $source_filename = $operand_one ;  <new_line>
    $target_phrase_name = $operand_two ;  <new_line>
    $target_filename = $operand_two ;  <new_line>
    if ( $operand_two eq "" )  <new_line>
    {  <new_line>
        $target_phrase_name = $operand_one ;  <new_line>
        $target_filename = $operand_one ;  <new_line>
    }  <new_line>


# no-space dashes-long-line  <new_line>
#  Strip off any path, and keep only the names  <new_line>
#  of the source and target files.  <new_line>

    $source_filename =~ s/^.*[\\\/]// ;  <new_line>
    $source_filename =~ s/^\.+// ;  <new_line>
    $target_filename =~ s/^.*[\\\/]// ;  <new_line>
    $target_filename =~ s/^\.+// ;  <new_line>


# no-space dashes-long-line  <new_line>
#  Insert the path into the filename variables.  <new_line>

    if ( $source_filename ne "" )  <new_line>
    {  <new_line>
        $source_filename = $global_dashrep_replacement{ "dashrep-path-prefix-for-file-reading" } . $source_filename ;  <new_line>
    }  <new_line>
    if ( $target_filename ne "" )  <new_line>
    {  <new_line>
        $target_filename = $global_dashrep_replacement{ "dashrep-path-prefix-for-file-writing" } . $target_filename ;  <new_line>
    }  <new_line>


# no-space dashes-long-line  <new_line>
#  If requested, log the action details.  <new_line>

    if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
    {  <new_line>
        $global_trace_log .= "{{trace; action " . $action_name . " has operand one " . $operand_one . " has operand two " . $operand_two . " has operand three " . $operand_three . " has operand four " . $operand_four . " has operand five " . $operand_five . " has default result " . $action_result . " has source_filename " . $source_filename . " has target_filename " . $target_filename . " has source_phrase_name " . $source_phrase_name . " has target_phrase_name " . $target_phrase_name . "}}\n" ;  <new_line>
    }  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  copy-from-file-to-phrase  <new_line>

    if ( $action_name eq "copy-from-file-to-phrase" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $target_phrase_name eq "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $target_phrase_name . "]" ;  <new_line>
        } elsif ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $source_filename . " not found, or could not be opened]" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $all_lines = "" ;  <new_line>
            $line_ending = "" ;  <new_line>
            $line_number = 0 ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ "yes-or-no-indicate-line-endings" } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ "yes-or-no-indicate-line-endings" } = "no" ;  <new_line>
            }  <new_line>
            if ( ( exists( $global_dashrep_replacement{ "yes-or-no-indicate-line-endings" } ) ) && ( $global_dashrep_replacement{ "yes-or-no-indicate-line-endings" } eq "yes" ) )  <new_line>
            {  <new_line>
                $line_ending = " end-of-line-here " ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $line_ending = " " ;  <new_line>
            }  <new_line>
            while ( $input_line = <INFILE> )  <new_line>
            {  <new_line>
                chomp( $input_line ) ;  <new_line>
                $input_line =~ s/[\t\f\n\r]+/ /g ;  <new_line>
                $input_line =~ s/^ +/ / ;  <new_line>
                $input_line =~ s/ +$/ / ;  <new_line>
                if ( $action_name eq "copy-from-file-to-phrase" )  <new_line>
                {  <new_line>
                    if ( ( $input_line ne "" ) || ( $line_ending ne " " ) )  <new_line>
                    {  <new_line>
                        $all_lines .= $input_line . $line_ending ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $target_phrase_name } = $all_lines ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from file " . $source_filename . " to phrase " . $target_phrase_name . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the actions:  <new_line>
#  find-line-in-file-that-begins-with-text  <new_line>
#  find-lines-in-file-that-begin-with-any-listed-word  <new_line>
#  find-lines-in-file-that-begin-with-any-two-words-listed  <new_line>

    } elsif ( ( $action_name eq "find-line-in-file-that-begins-with-text" ) || ( $action_name eq "find-lines-in-file-that-begin-with-any-listed-word" ) || ( $action_name eq "find-lines-in-file-that-begin-with-any-two-words-listed" ) )  <new_line>
    {  <new_line>
        $list_of_storage_names = "" ;  <new_line>
        if ( ( $source_filename eq "" ) || ( $operand_two eq "" ) || ( $operand_three eq "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $operand_two . " and " . $operand_three . "]" ;  <new_line>
        } elsif ( ( $action_name eq "find-line-in-file-that-begins-with-text" ) && ( ( not( exists( $global_dashrep_replacement{ $operand_two } ) ) ) || ( $global_dashrep_replacement{ $operand_two } !~ /[^ ]/ ) ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has empty search word in phrase " . $operand_two . "]" ;  <new_line>
        } elsif ( ( ( $action_name eq "find-lines-in-file-that-begin-with-any-listed-word" ) || ( $action_name eq "find-lines-in-file-that-begin-with-any-two-words-listed" ) ) && ( ( not( exists( $global_dashrep_replacement{ $operand_two } ) ) ) || ( $global_dashrep_replacement{ $operand_two } !~ /[^ ]/ ) ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has no search words in phrase " . $operand_two . "]" ;  <new_line>
        } elsif ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $source_filename . " not found, or could not be opened]" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            if ( $action_name eq "find-line-in-file-that-begins-with-text" )  <new_line>
            {  <new_line>
                $string_to_find = $global_dashrep_replacement{ $operand_two } ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; searching in file " . $source_filename . " for string " . $string_to_find . "}}\n" ;  <new_line>
                }  <new_line>
                $length_of_string = length( $string_to_find ) ;  <new_line>
                while ( $input_line = <INFILE> )  <new_line>
                {  <new_line>
                    chomp( $input_line ) ;  <new_line>
                    $possible_match = substr( $input_line , 0 , $length_of_string ) ;  <new_line>
                    if ( $possible_match eq $string_to_find )  <new_line>
                    {  <new_line>
                        $global_dashrep_replacement{ $operand_three } = $input_line ;  <new_line>
                        if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                        {  <new_line>
                            $global_trace_log .= "{{trace; in file " . $source_filename . " found starting string " . $string_to_find . "}}\n" ;  <new_line>
                        }  <new_line>
                        last ;  <new_line>
                    }  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; searching in file " . $source_filename . " for words in phrase " . $operand_two . "}}\n" ;  <new_line>
                }  <new_line>
                $list_of_words_as_text = $global_dashrep_replacement{ $operand_two } ;  <new_line>
                $list_of_words_as_text =~ s/^ +// ;  <new_line>
                $list_of_words_as_text =~ s/ +$//s ;  <new_line>
                if ( $list_of_words_as_text =~ / / )  <new_line>
                {  <new_line>
                    @list_of_words = split( /[ \n\r]+/ , $list_of_words_as_text ) ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    @list_of_words = ( ) ;  <new_line>
                    $list_of_words[ 0 ] = $list_of_words_as_text ;  <new_line>
                }  <new_line>
                foreach $word ( @list_of_words )  <new_line>
                {  <new_line>
                    $matching_text{ $word } = "match" ;  <new_line>
                }  <new_line>
                if ( $action_name eq "find-lines-in-file-that-begin-with-any-listed-word" )  <new_line>
                {  <new_line>
                    $words_to_match = 1 ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $words_to_match = 2 ;  <new_line>
                }  <new_line>
                while ( $input_line = <INFILE> )  <new_line>
                {  <new_line>
                    chomp( $input_line ) ;  <new_line>
                    $length_of_first_word = index( $input_line , " " ) ;  <new_line>
                    $possible_match = substr( $input_line , 0 , $length_of_first_word ) ;  <new_line>
                    if ( ( exists( $matching_text{ $possible_match } ) ) && ( $matching_text{ $possible_match } eq "match" ) )  <new_line>
                    {  <new_line>
                        if ( $words_to_match == 1 )  <new_line>
                        {  <new_line>
                            $storage_name = "dashrep-storage-" . sprintf( "%d" , $global_storage_number ) ;  <new_line>
                            $global_storage_number ++ ;  <new_line>
                            $global_dashrep_replacement{ $storage_name } = $input_line ;  <new_line>
                            $list_of_storage_names .= $storage_name . " " ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            if ( $input_line =~ /^[^ ]+ +([^ ]+)(( )|($))/ )  <new_line>
                            {  <new_line>
                                $second_word = $1 ;  <new_line>
                                if ( ( exists( $matching_text{ $second_word } ) ) && ( $matching_text{ $second_word } eq "match" ) )  <new_line>
                                {  <new_line>
                                    $storage_name = "dashrep-storage-" . sprintf( "%d" , $global_storage_number ) ;  <new_line>
                                    $global_storage_number ++ ;  <new_line>
                                    if ( $list_of_storage_names eq "" )  <new_line>
                                    {  <new_line>
                                        $list_of_storage_names = $storage_name . " " ;  <new_line>
                                    } else  <new_line>
                                    {  <new_line>
                                        $list_of_storage_names .= $storage_name . " " ;  <new_line>
                                    }  <new_line>
                                    $global_dashrep_replacement{ $storage_name } = $input_line ;  <new_line>
                                }  <new_line>
                            }  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
                $list_of_storage_names =~ s/ +$// ;  <new_line>
                $global_dashrep_replacement{ $operand_three } = $list_of_storage_names ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; finished searching, previous message indicates any matches " . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  get-definitions-from-file  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "get-definitions-from-file" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $operand_two . "]" ;  <new_line>
        } elsif ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message = "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( -e $source_filename )  <new_line>
            {  <new_line>
                $possible_error_message .= " [warning, file named " . $source_filename . " found, but could not be opened]" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $possible_error_message .= " [warning, file named " . $source_filename . " not found]" ;  <new_line>
            }  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $source_definitions = "" ;  <new_line>
            while ( $input_line = <INFILE> )  <new_line>
            {  <new_line>
                chomp( $input_line ) ;  <new_line>
                $input_line =~ s/[\n\r\f\t]+/ /g ;  <new_line>
                if ( ( defined( $input_line ) ) && ( $input_line =~ /[^ ]/ ) )  <new_line>
                {  <new_line>
                    $source_definitions .= $input_line . " " ;  <new_line>
                }  <new_line>
            }  <new_line>
            $numeric_return_value = &dashrep_import_replacements( $source_definitions ) ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; imported " . $numeric_return_value . " definitions from file: " . $source_filename . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the actions:  <new_line>
#  generate-list-of-files-in-current-read-directory  <new_line>
#  generate-list-of-folders-in-current-read-directory  <new_line>
#  <new_line>
#  The current read directory is already specified  <new_line>
#  in a Dashrep phrase.  <new_line>

    } elsif ( ( $action_name eq "generate-list-of-files-in-current-read-directory" ) || ( $action_name eq "generate-list-of-folders-in-current-read-directory" ) )  <new_line>
    {  <new_line>
        if ( ( $operand_one eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $operand_two . "]" ;  <new_line>
        } elsif ( exists( $global_dashrep_replacement{ "dashrep-path-prefix-for-file-reading" } ) )  <new_line>
        {  <new_line>
            $directory = $global_dashrep_replacement{ "dashrep-path-prefix-for-file-reading" } ;  <new_line>
            if ( ( $directory eq "" ) || ( $directory !~ /[\\\/]$/ ) )  <new_line>
            {  <new_line>
                $directory = './' ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, directory " . $directory . " is invalid so using local directory}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
            if ( opendir( READDIR , $directory ) )  <new_line>
            {  <new_line>
                while ( defined( $file_name = readdir( READDIR ) ) )  <new_line>
                {  <new_line>
                    if ( $file_name !~ /^\./ )  <new_line>
                    {  <new_line>
                        $full_path = $directory . $file_name ;  <new_line>
                        if ( $action_name eq "generate-list-of-folders-in-current-read-directory" )  <new_line>
                        {  <new_line>
                            if ( -d $full_path )  <new_line>
                            {  <new_line>
                                $list_of_file_names .= $file_name . " " ;  <new_line>
                            }  <new_line>
                        } elsif ( $action_name eq "generate-list-of-files-in-current-read-directory" )  <new_line>
                        {  <new_line>
                            if ( -f $full_path )  <new_line>
                            {  <new_line>
                                $list_of_file_names .= $file_name . " " ;  <new_line>
                            }  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
                $list_of_file_names =~ s / +$// ;  <new_line>
                $global_dashrep_replacement{ $operands_all } = $list_of_file_names ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; listed files or folders in directory " . $directory . "}}\n" ;  <new_line>
                }  <new_line>
                closedir( READDIR ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, cannot list files in directory " . $directory . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  yes-or-no-file-exists  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "yes-or-no-file-exists" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $operand_two . "]" ;  <new_line>
        } elsif ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $action_result = " yes " ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; file exists: " . $source_filename . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            $action_result = " no " ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; file does not exist: " . $source_filename . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  yes-or-no-folder-exists  <new_line>

    } elsif ( $action_name eq "yes-or-no-folder-exists" )  <new_line>
    {  <new_line>
        if ( $operand_one eq "" )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has empty operand " . $operand_one . "]" ;  <new_line>
        } elsif ( -d $operand_one )  <new_line>
        {  <new_line>
            $action_result = " yes " ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; folder exists: " . $operand_one . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            $action_result = " no " ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; folder does not exist: " . $operand_one . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  modification-time-of-file  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "modification-time-of-file" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $operand_two . "]" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            ( $read_time , $write_time ) = ( stat( $source_filename ) )[8,9] ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; modification time of file " . $source_filename . " is " . $write_time . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        $action_result = " " . $write_time . " " ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  set-file-permission-public-read  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "set-file-permission-public-read" )  <new_line>
    {  <new_line>
        if ( ( $target_filename eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $target_filename . " and " . $operand_two . "]" ;  <new_line>
        } elsif ( not( chmod( $global_file_public_read_protection_mode , $target_filename ) ) )  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: protection removal for output file " . $target_filename . "  not successful}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  size-of-file  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "size-of-file" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $operand_two . "]" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $file_size = sprintf( "%d" , ( stat( $source_filename ) )[7] ) ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; size of file " . $source_filename . " is " . $file_size . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        $action_result = " " . $file_size . " " ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  copy-from-phrase-append-to-file  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "copy-from-phrase-append-to-file" )  <new_line>
    {  <new_line>
        if ( $target_filename eq "" )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_phrase_name . " and " . $target_filename . "]" ;  <new_line>
        } elsif ( $global_dashrep_replacement{ "yes-or-no-permission-to-append-to-files" } ne "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; attempt to copy from phrase " . $source_phrase_name . " to end of file " . $target_filename . "}}\n" ;  <new_line>
            $possible_error_message .= " [warning, do not have permission to append to files]" ;  <new_line>
        } elsif ( open ( OUTFILE , '>>' . $target_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $target_filename . " could not be opened for writing]" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $source_phrase_name } ) )  <new_line>
            {  <new_line>
                print OUTFILE $global_dashrep_replacement{ $source_phrase_name } . "\n" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                print OUTFILE $source_phrase_name . "\n" ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from phrase " . $source_phrase_name . " to end of file " . $target_filename . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( OUTFILE ) ;  <new_line>
        if ( not( chmod( $global_file_write_protection_mode , $target_filename ) ) )  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: protection of output file " . $target_filename . "  not successful}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  copy-append-file-to-file  <new_line>
#  <new_line>
#  The filenames are edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "copy-append-file-to-file" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $target_filename eq "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $target_filename . "]" ;  <new_line>
        } elsif ( $global_dashrep_replacement{ "yes-or-no-permission-to-append-to-files" } ne "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; attempt to copy from phrase " . $source_phrase_name . " to end of file " . $target_filename . "}}\n" ;  <new_line>
            $possible_error_message .= " [warning, do not have permission to append to files]" ;  <new_line>
        }  <new_line>
        if ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $source_filename . " not found, or could not be opened]" ;  <new_line>
        }  <new_line>
        if ( open ( OUTFILE , '>>' . $target_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $target_filename . " could not be opened for writing]" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            while ( $input_line = <INFILE> )  <new_line>
            {  <new_line>
                chomp( $input_line ) ;  <new_line>
                print OUTFILE $input_line . "\n" ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from file " . $source_filename . " to file " . $target_filename . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
        close( OUTFILE ) ;  <new_line>
        if ( not( chmod( $global_file_write_protection_mode , $target_filename ) ) )  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: protection of output file " . $target_filename . "  not successful}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  delete-file  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "delete-file" )  <new_line>
    {  <new_line>
        if ( ( $target_filename eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $target_filename . " and " . $operand_two . "]" ;  <new_line>
        } elsif ( $global_dashrep_replacement{ "yes-or-no-permission-to-delete-or-overwrite-files" } ne "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; attempt to delete file: " . $target_filename . "}}\n" ;  <new_line>
            $possible_error_message .= " [warning, do not have permission to delete or overwrite files]" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            unlink $target_filename ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; deleted file: " . $target_filename . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  rename-file  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "rename-file" )  <new_line>
    {  <new_line>
        if ( $global_dashrep_replacement{ "yes-or-no-permission-to-delete-or-overwrite-files" } ne "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; attempt to rename file: " . $source_filename . "}}\n" ;  <new_line>
            $possible_error_message .= " [warning, do not have permission to delete or overwrite or rename files]" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            rename( $source_filename , $target_filename ) ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; renamed file " . $source_filename . " to " . $target_filename . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  create-empty-file  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    } elsif ( $action_name eq "create-empty-file" )  <new_line>
    {  <new_line>
        if ( ( $target_filename eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $target_filename . " and " . $operand_two . "]" ;  <new_line>
        } elsif ( $global_dashrep_replacement{ "yes-or-no-permission-to-delete-or-overwrite-files" } ne "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; attempt to create empty file: " . $target_filename . "}}\n" ;  <new_line>
            $possible_error_message .= " [warning, do not have permission to delete or overwrite files]" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( open ( OUTFILE , '>' . $target_filename ) )  <new_line>
            {  <new_line>
                $possible_error_message .= "" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $possible_error_message .= " [warning, file named " . $target_filename . " could not be created]" ;  <new_line>
            }  <new_line>
            if ( $possible_error_message eq "" )  <new_line>
            {  <new_line>
                print OUTFILE "" ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; created empty file: " . $target_filename . "}}\n" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
            close( OUTFILE ) ;  <new_line>
            if ( not( chmod( $global_file_write_protection_mode , $target_filename ) ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning: protection of output file " . $target_filename . "  not successful}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  create-empty-sub-folder  <new_line>
#  <new_line>
#  The created folder must be directly beneath  <new_line>
#  the currently specified write directory.  <new_line>

    } elsif ( $action_name eq "create-empty-sub-folder" )  <new_line>
    {  <new_line>
        if ( ( $operand_one eq "" ) || ( $operand_one !~ /^[a-z0-9_\-]+$/i ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operand " . $operand_one . "]" ;  <new_line>
        } elsif ( $global_dashrep_replacement{ "yes-or-no-permission-to-delete-or-overwrite-files" } ne "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; attempt to create empty folder: " . $global_dashrep_replacement{ "dashrep-path-prefix-for-file-writing" } . "}}\n" ;  <new_line>
            $possible_error_message .= " [warning, do not have permission to create files or folders]" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $target_sub_folder = $global_dashrep_replacement{ "dashrep-path-prefix-for-file-writing" } . $operand_one ;  <new_line>
            if ( $target_sub_folder =~ /([\/\\])/ )  <new_line>
            {  <new_line>
                $slash_or_backslash_for_path = $1 ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $slash_or_backslash_for_path = '/' ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-path-prefix-for-file-writing" } !~ /[\/\\]$/ )  <new_line>
            {  <new_line>
                $target_sub_folder = $global_dashrep_replacement{ "dashrep-path-prefix-for-file-writing" } . $slash_or_backslash_for_path . $operand_one ;  <new_line>
            }  <new_line>
            if ( -d $target_sub_folder )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; sub-folder " . $target_sub_folder . " already exists, so not created". "}}\n" ;  <new_line>
                }  <new_line>
                $possible_error_message .= "" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                umask( 0077 ) ;  <new_line>
                if ( mkdir( $target_sub_folder ) )  <new_line>
                {  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; sub-folder " . $target_sub_folder . " created". "}}\n" ;  <new_line>
                    }  <new_line>
                } else  <new_line>
                {  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; sub-folder " . $target_sub_folder . " could not be created". "}}\n" ;  <new_line>
                    }  <new_line>
                    $possible_error_message .= " [warning, sub-folder named " . $target_sub_folder . " could not be created]" ;  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $possible_error_message ne "" )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  copy-from-columns-in-file-to-named-phrases  <new_line>

    } elsif ( $action_name eq "copy-from-columns-in-file-to-named-phrases" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $operand_two eq "" ) || ( $operand_three eq "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $operand_two . " and " . $operand_three . "]" ;  <new_line>
        } elsif ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $source_filename . " not found, or could not be opened]" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $temp_text = $global_dashrep_replacement{ $operand_two } ;  <new_line>
            $temp_text =~ s/^ +// ;  <new_line>
            $temp_text =~ s/ +$//s ;  <new_line>
            if ( $temp_text =~ / / )  <new_line>
            {  <new_line>
                @phrase_naming_convention_for_column = split( /[ \n\r]+/ , $temp_text ) ;  <new_line>
                $number_of_column_names = scalar( @phrase_naming_convention_for_column ) ;  <new_line>
                $prefix_text = $phrase_naming_convention_for_column[ 0 ] ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $phrase_naming_convention_for_column[ 1 ] = "" ;  <new_line>
                $number_of_column_names = 2 ;  <new_line>
                $prefix_text = $temp_text ;  <new_line>
            }  <new_line>
            if ( $prefix_text !~ /^[^ ]+$/ )  <new_line>
            {  <new_line>
                $possible_error_message .= " [warning, action " . $action_name . " has prefix of " . $prefix_text . " that is not valid]" ;  <new_line>
            }  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $name_of_phrase_that_contains_list_of_index_values = $operand_three ;  <new_line>
            if ( $name_of_phrase_that_contains_list_of_index_values !~ /^[a-z0-9_\-]+$/i )  <new_line>
            {  <new_line>
                $possible_error_message .= " [warning, action " . $action_name . " has invalid third operand " . $name_of_phrase_that_contains_list_of_index_values . "]" ;  <new_line>
            }  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $list_of_unique_values = "" ;  <new_line>
            $global_dashrep_replacement{ $name_of_phrase_that_contains_list_of_index_values } = $list_of_unique_values ;  <new_line>
            if ( ( exists( $global_dashrep_replacement{ "yes-or-no-use-two-spaces-as-column-delimiter" } ) ) && ( $global_dashrep_replacement{ "yes-or-no-use-two-spaces-as-column-delimiter" } eq "yes" ) )  <new_line>
            {  <new_line>
                $use_two_spaces_as_delimiter = "yes" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $use_two_spaces_as_delimiter = "no" ;  <new_line>
            }  <new_line>
            while ( $input_line = <INFILE> )  <new_line>
            {  <new_line>
                chomp( $input_line ) ;  <new_line>
                $input_line =~ s/[ \n\t]+$// ;  <new_line>
                if ( $use_two_spaces_as_delimiter eq "yes" )  <new_line>
                {  <new_line>
                    @text_item_in_column = split( /  +/ , $input_line ) ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    @text_item_in_column = split( /[\t ]/ , $input_line ) ;  <new_line>
                }  <new_line>
                $unique_value = $text_item_in_column[ 0 ] ;  <new_line>
                if ( $unique_value =~ / / )  <new_line>
                {  <new_line>
                    $unique_value =~ s/ +/_/g ;  <new_line>
                }  <new_line>
                $number_of_columns = scalar( @text_item_in_column ) ;  <new_line>
                if ( $number_of_columns > $number_of_column_names )  <new_line>
                {  <new_line>
                    $number_of_columns = $number_of_column_names ;  <new_line>
                }  <new_line>
                if ( $number_of_columns > 0 )  <new_line>
                {  <new_line>
                    $list_of_unique_values .= " " . $unique_value ;  <new_line>
                    for ( $column_pointer = 2 ; $column_pointer <= $number_of_column_names ; $column_pointer ++ )  <new_line>
                    {  <new_line>
                        if ( $phrase_naming_convention_for_column[ $column_pointer - 1 ] ne "" )  <new_line>
                        {  <new_line>
                            $phrase_naming_convention_for_this_column = $prefix_text . "-" . $unique_value . "-" . $phrase_naming_convention_for_column[ $column_pointer - 1 ] ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $phrase_naming_convention_for_this_column = $prefix_text . "-" . $unique_value ;  <new_line>
                        }  <new_line>
                        if ( $column_pointer <= $number_of_columns )  <new_line>
                        {  <new_line>
                            $global_dashrep_replacement{ $phrase_naming_convention_for_this_column } = $text_item_in_column[ $column_pointer - 1 ] ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $global_dashrep_replacement{ $phrase_naming_convention_for_this_column } = "" ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            $list_of_unique_values =~ s/^ +// ;  <new_line>
            $global_dashrep_replacement{ $name_of_phrase_that_contains_list_of_index_values } = $list_of_unique_values ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from columns in file " . $source_filename . " to phrase names specified in phrase " . $target_phrase_name . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        if ( $possible_error_message ne "" )  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  copy-from-columns-in-file-to-column-lists  <new_line>

    } elsif ( $action_name eq "copy-from-columns-in-file-to-column-lists" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $operand_two eq "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $operand_two . "]" ;  <new_line>
        } elsif ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $source_filename . " not found, or could not be opened]" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $list_name_prefix = $operand_two ;  <new_line>
            @list_of_values_in_column = ( ) ;  <new_line>
            $minimum_number_of_columns = 999 ;  <new_line>
            while ( $input_line = <INFILE> )  <new_line>
            {  <new_line>
                chomp( $input_line ) ;  <new_line>
                $input_line =~ s/[\n\t]+/ /g ;  <new_line>
                $input_line =~ s/^ +// ;  <new_line>
                $input_line =~ s/ +$// ;  <new_line>
                @value_in_column = split( / +/ , $input_line ) ;  <new_line>
                $number_of_columns = scalar( @value_in_column ) ;  <new_line>
                if ( $number_of_columns < 1 )  <new_line>
                {  <new_line>
                    next ;  <new_line>
                } elsif ( $number_of_columns < $minimum_number_of_columns )  <new_line>
                {  <new_line>
                    $minimum_number_of_columns = $number_of_columns ;  <new_line>
                }  <new_line>
                if ( $number_of_columns > 0 )  <new_line>
                {  <new_line>
                    for ( $column_pointer = 1 ; $column_pointer <= $minimum_number_of_columns ; $column_pointer ++ )  <new_line>
                    {  <new_line>
                        $list_of_values_in_column[ $column_pointer ] .= $value_in_column[ $column_pointer - 1 ] . " " ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            for ( $column_pointer = 1 ; $column_pointer <= $minimum_number_of_columns ; $column_pointer ++ )  <new_line>
            {  <new_line>
                $list_of_values_in_column[ $column_pointer ] =~ s/ +$// ;  <new_line>
                $global_dashrep_replacement{ $list_name_prefix . "-" . $column_pointer } = $list_of_values_in_column[ $column_pointer ] ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from columns in file " . $source_filename . " to phrase names with prefix " . $operand_two . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        if ( $possible_error_message ne "" )  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the actions:  <new_line>
#  gather-tagged-info-from-file  <new_line>
#  gather-from-tagged-file-one-entry  <new_line>

    } elsif ( ( $action_name eq "gather-tagged-info-from-file" ) || ( $action_name eq "gather-from-tagged-file-one-entry" ) )  <new_line>
    {  <new_line>
        $accumulated_matching_entry_info = "" ;  <new_line>
        if ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning: file named " . $source_filename . " not found, or could not be opened" . "]\n" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $entry_begin = $global_dashrep_replacement{ "dashrep-gather-tag-begin" } ;  <new_line>
            if ( $entry_begin !~ /^[^ ]+$/ )  <new_line>
            {  <new_line>
                $entry_begin = "entry_begin" ;  <new_line>
            }  <new_line>
            $entry_end = $global_dashrep_replacement{ "dashrep-gather-tag-end" } ;  <new_line>
            if ( $entry_end !~ /^[^ ]+$/ )  <new_line>
            {  <new_line>
                $entry_end = "entry_end" ;  <new_line>
            }  <new_line>
            $entry_unique = $global_dashrep_replacement{ "dashrep-gather-tag-unique" } ;  <new_line>
            if ( $entry_unique !~ /^[^ ]+$/ )  <new_line>
            {  <new_line>
                $entry_unique = "url" ;  <new_line>
            }  <new_line>
            $entry_delete = $global_dashrep_replacement{ "dashrep-gather-tag-delete" } ;  <new_line>
            if ( $entry_delete !~ /^[^ ]+$/ )  <new_line>
            {  <new_line>
                $entry_delete = "delete_id" ;  <new_line>
            }  <new_line>
            if ( $action_name eq "gather-from-tagged-file-one-entry" )  <new_line>
            {  <new_line>
                $entry_matching_id = $global_dashrep_replacement{ "dashrep-gather-tag-matching-id" } ;  <new_line>
                if ( $entry_matching_id !~ /^[^ ]+$/ )  <new_line>
                {  <new_line>
                    $entry_matching_id = "1" ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "gather-tagged-info-from-file" )  <new_line>
            {  <new_line>
                $entry_matching_id = "" ;  <new_line>
            }  <new_line>
            $accumulated_matching_entry_info = "" ;  <new_line>
            $possible_matching_entry_info = "" ;  <new_line>
            $unique_value = "" ;  <new_line>
            $list_of_tag_values_in_sequence_encountered = "" ;  <new_line>
            %content_for_tag = ( ) ;  <new_line>
            %found_unique_value = ( ) ;  <new_line>
            %exists_tag_name = ( ) ;  <new_line>
            $line_status = "between" ;  <new_line>
            while ( $input_line = <INFILE> )  <new_line>
            {  <new_line>
                chomp( $input_line ) ;  <new_line>
                $pointer = index( $input_line , "\r" ) ;  <new_line>
                if ( $pointer >= 0 )  <new_line>
                {  <new_line>
                    $input_line =~ s/[\r\n]+//gs ;  <new_line>
                }  <new_line>
                if ( $entry_matching_id ne "" )  <new_line>
                {  <new_line>
#                   This section of code applies to action: gather-from-tagged-file-one-entry  <new_line>
                    if ( $input_line =~ /^ *([^ ]+) *$/ )  <new_line>
                    {  <new_line>
                        $first_word = $1 ;  <new_line>
                        if ( $first_word eq $entry_begin )  <new_line>
                        {  <new_line>
                            $line_status = "within" ;  <new_line>
                            $possible_matching_entry_info = "" ;  <new_line>
                        } elsif ( $first_word eq $entry_end )  <new_line>
                        {  <new_line>
                            if ( $line_status eq "within-matching" )  <new_line>
                            {  <new_line>
                                $accumulated_matching_entry_info .= $possible_matching_entry_info ;  <new_line>
                            }  <new_line>
                            $possible_matching_entry_info = "" ;  <new_line>
                            $line_status = "between" ;  <new_line>
                        } elsif ( ( $line_status eq "within" ) || ( $line_status eq "within-matching" ) )  <new_line>
                        {  <new_line>
                            $possible_matching_entry_info .= $input_line . "\n" ;  <new_line>
                        }  <new_line>

                    } elsif ( $input_line =~ /^ *([^ ]+) +([^ \t\n\r]+) *$/ )  <new_line>
                    {  <new_line>
                        $first_word = $1 ;  <new_line>
                        $second_word = $2 ;  <new_line>
                        if ( $first_word eq $entry_unique )  <new_line>
                        {  <new_line>
                            if ( $second_word eq $entry_matching_id )  <new_line>
                            {  <new_line>
                                $line_status = "within-matching" ;  <new_line>
                                $possible_matching_entry_info .= $input_line . "\n" ;  <new_line>
                            } else  <new_line>
                            {  <new_line>
                                $line_status = "within-not-matching" ;  <new_line>
                                $possible_matching_entry_info = "" ;  <new_line>
                            }  <new_line>
                        } elsif ( $first_word eq $entry_delete )  <new_line>
                        {  <new_line>
                            if ( $second_word eq $entry_matching_id )  <new_line>
                            {  <new_line>
                                $accumulated_matching_entry_info = "" ;  <new_line>
                            } else  <new_line>
                            {  <new_line>
                                $possible_matching_entry_info = "" ;  <new_line>
                                $line_status = "between" ;  <new_line>
                            }  <new_line>
                        } elsif ( ( $line_status eq "within" ) || ( $line_status eq "within-matching" ) )  <new_line>
                        {  <new_line>
                            $possible_matching_entry_info .= $input_line . "\n" ;  <new_line>
                        }  <new_line>
                    } elsif ( ( $line_status eq "within" ) || ( $line_status eq "within-matching" ) )  <new_line>
                    {  <new_line>
                        $possible_matching_entry_info .= $input_line . "\n" ;  <new_line>
                    }  <new_line>
                } else  <new_line>
                {  <new_line>
#                   This section of code applies to action: gather-tagged-info-from-file  <new_line>
                    if ( $input_line =~ /^ *([^ ]+) *$/ )  <new_line>
                    {  <new_line>
                        $first_word = $1 ;  <new_line>
                        if ( $first_word eq "multi_line_end" )  <new_line>
                        {  <new_line>
                            $line_status = "within" ;  <new_line>
                        } elsif ( ( $first_word eq $entry_end ) || ( $first_word eq $entry_begin ) )  <new_line>
                        {  <new_line>
                            if ( $unique_value =~ /^[^ ]+$/ )  <new_line>
                            {  <new_line>
                                foreach $tag_name ( keys( %content_for_tag ) )  <new_line>
                                {  <new_line>
                                    $global_dashrep_replacement{ $tag_name . "-value-for-unique-id-" . $unique_value } = $content_for_tag{ $tag_name } ;  <new_line>
                                }  <new_line>
                            } elsif ( ( $entry_matching_id eq "" ) && ( $first_word eq $entry_end ) )  <new_line>
                            {  <new_line>
                                $global_trace_log .= "{{trace; warning: action " . $action_name . " encountered a set of items that do not contain a unique value, so no definitions were created for this set of items" . "}}\n" ;  <new_line>
                            }  <new_line>
                            $unique_value = "" ;  <new_line>
                            %content_for_tag = ( ) ;  <new_line>
                            if ( $first_word eq $entry_begin )  <new_line>
                            {  <new_line>
                                $line_status = "within" ;  <new_line>
                            } else  <new_line>
                            {  <new_line>
                                $line_status = "between" ;  <new_line>
                            }  <new_line>
                        } elsif ( $line_status eq "within_multiline" )  <new_line>
                        {  <new_line>
                            $content_for_tag{ $multiline_value_name } .= $input_line . " " ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $content_for_tag{ $first_word } = "" ;  <new_line>
                        }  <new_line>
                    } elsif ( $line_status eq "within_multiline" )  <new_line>
                    {  <new_line>
                        $content_for_tag{ $multiline_value_name } .= $input_line . " " ;  <new_line>
                    } elsif ( $input_line =~ /^ *([^ ]+) +([^ ].*)$/ )  <new_line>
                    {  <new_line>
                        $first_word = $1 ;  <new_line>
                        $remainder_of_line = $2 ;  <new_line>
                        if ( $first_word eq $entry_unique )  <new_line>
                        {  <new_line>
                            $unique_value = $remainder_of_line ;  <new_line>
                            $unique_value =~ s/[ \n\r]+/_/g ;  <new_line>
                            if ( not( exists( $found_unique_value{ $unique_value } ) ) )  <new_line>
                            {  <new_line>
                                $found_unique_value{ $unique_value } = "found" ;  <new_line>
                            }  <new_line>
                        } elsif ( $first_word eq $entry_delete )  <new_line>
                        {  <new_line>
                            $unique_value = $remainder_of_line ;  <new_line>
                            $unique_value =~ s/[ \n\r]+/_/g ;  <new_line>
                            $found_unique_value{ $unique_value } = "delete" ;  <new_line>
                        } elsif ( $remainder_of_line =~ /^ *multi_line_begin/ )  <new_line>
                        {  <new_line>
                            $line_status = "within_multiline" ;  <new_line>
                            $multiline_value_name = $first_word ;  <new_line>
                            $content_for_tag{ $multiline_value_name } = "" ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $content_for_tag{ $first_word } = $remainder_of_line ;  <new_line>
                            if ( not( exists( $exists_tag_name{ $first_word } ) ) )  <new_line>
                            {  <new_line>
                                $exists_tag_name{ $first_word } = "yes" ;  <new_line>
                                if ( $list_of_tag_values_in_sequence_encountered eq "" )  <new_line>
                                {  <new_line>
                                    $list_of_tag_values_in_sequence_encountered = $entry_unique . " " ;  <new_line>
                                } else  <new_line>
                                {  <new_line>
                                    $list_of_tag_values_in_sequence_encountered .= " " ;  <new_line>
                                }  <new_line>
                                $list_of_tag_values_in_sequence_encountered .= $first_word ;  <new_line>
                            }  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $action_name eq "gather-from-tagged-file-one-entry" )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $target_phrase_name } = $accumulated_matching_entry_info ;  <new_line>
            } elsif ( $action_name eq "gather-tagged-info-from-file" )  <new_line>
            {  <new_line>
                if ( $unique_value =~ /^[^ ]+$/ )  <new_line>
                {  <new_line>
                    foreach $tag_name ( keys( %content_for_tag ) )  <new_line>
                    {  <new_line>
                        $global_dashrep_replacement{ $tag_name . "-value-for-unique-id-" . $unique_value } = $content_for_tag{ $tag_name } ;  <new_line>
                    }  <new_line>
                }  <new_line>
                $list_of_unique_values = "" ;  <new_line>
                foreach $unique_value ( keys( %found_unique_value ) )  <new_line>
                {  <new_line>
                    if ( $found_unique_value{ $unique_value } ne "delete" )  <new_line>
                    {  <new_line>
                        if ( $list_of_unique_values ne "" )  <new_line>
                        {  <new_line>
                            $list_of_unique_values .= " " ;  <new_line>
                        }  <new_line>
                        $list_of_unique_values .= $unique_value ;  <new_line>
                    }  <new_line>
                }  <new_line>
                $global_dashrep_replacement{ $target_phrase_name } = $list_of_unique_values ;  <new_line>
                $list_of_tag_names = "" ;  <new_line>
                foreach $tag_name ( keys( %exists_tag_name ) )  <new_line>
                {  <new_line>
                    if ( $list_of_tag_names ne "" )  <new_line>
                    {  <new_line>
                        $list_of_tag_names .= " " ;  <new_line>
                    }  <new_line>
                    $list_of_tag_names .= $tag_name ;  <new_line>
                }  <new_line>
                $global_dashrep_replacement{ "dashrep-gathered-tag-names" } = $list_of_tag_names ;  <new_line>
                $global_dashrep_replacement{ "dashrep-gathered-tag-names-in-sequence" } = $list_of_tag_values_in_sequence_encountered ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; did action " . $action_name ." with file " . $source_filename . " and target phrase " . $target_phrase_name . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  write-gathered-listed-items-to-end-of-file  <new_line>

    } elsif ( $action_name eq "write-gathered-listed-items-to-end-of-file" )  <new_line>
    {  <new_line>
        $accumulated_text = "" ;  <new_line>
        if ( $target_filename eq "" )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_phrase_name . " and " . $target_filename . "]" ;  <new_line>
        } elsif ( $global_dashrep_replacement{ "yes-or-no-permission-to-append-to-files" } ne "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; attempt to copy from phrase " . $source_phrase_name . " to end of file " . $target_filename . "}}\n" ;  <new_line>
            $possible_error_message .= " [warning, do not have permission to append to files]" ;  <new_line>
        } elsif ( open ( OUTFILE , '>>' . $target_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $target_filename . " could not be opened for writing]" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $entry_begin = $global_dashrep_replacement{ "dashrep-gather-tag-begin" } ;  <new_line>
            $entry_end = $global_dashrep_replacement{ "dashrep-gather-tag-end" } ;  <new_line>
            $entry_unique = $global_dashrep_replacement{ "dashrep-gather-tag-unique" } ;  <new_line>
            @list_of_tag_names = ( ) ;  <new_line>
            if ( ( exists( $global_dashrep_replacement{ "dashrep-gathered-tag-names-in-sequence" } ) ) && ( $global_dashrep_replacement{ "dashrep-gathered-tag-names-in-sequence" } =~ /[^ ]/ ) )  <new_line>
            {  <new_line>
                @list_of_tag_names = split( /[ \n\r]+/ , $global_dashrep_replacement{ "dashrep-gathered-tag-names-in-sequence" } ) ;  <new_line>
            }  <new_line>
            @list_of_unique_values = ( ) ;  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                @list_of_unique_values = split( /[ \n\r]+/ , $global_dashrep_replacement{ $operand_one } ) ;  <new_line>
            }  <new_line>
            foreach $unique_value ( @list_of_unique_values )  <new_line>
            {  <new_line>
                $accumulated_text .= $entry_begin . "\n" ;  <new_line>
                $accumulated_text .= $entry_unique . " " . $unique_value . "\n" ;  <new_line>
                foreach $tag_name ( @list_of_tag_names )  <new_line>
                {  <new_line>
                    $phrase_name = $tag_name . "-value-for-unique-id-" . $unique_value ;  <new_line>
                    if ( exists( $global_dashrep_replacement{ $phrase_name } ) )  <new_line>
                    {  <new_line>
                        $accumulated_text .= $tag_name . " " . $global_dashrep_replacement{ $phrase_name } . "\n" ;  <new_line>
                    }  <new_line>
                }  <new_line>
                $accumulated_text .= $entry_end . "\n\n" ;  <new_line>
            }  <new_line>
            print OUTFILE $accumulated_text . "\n" ;  <new_line>

            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; wrote gathered selected items listed in phrase " . $source_phrase_name . " to end of file " . $target_filename . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( OUTFILE ) ;  <new_line>
        if ( not( chmod( $global_file_write_protection_mode , $target_filename ) ) )  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: protection of output file " . $target_filename . "  not successful}}\n" ;  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the action:  <new_line>
#  linewise-read-from-file-and-use-handler  <new_line>

    } elsif ( $action_name eq "linewise-read-from-file-and-use-handler" )  <new_line>
    {  <new_line>
        if ( ( $source_filename eq "" ) || ( $target_phrase_name eq "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_filename . " and " . $target_phrase_name . "]" ;  <new_line>
        } elsif ( open ( INFILE , '<' . $source_filename ) )  <new_line>
        {  <new_line>
            $possible_error_message .= "" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, file named " . $source_filename . " not found, or could not be opened]" ;  <new_line>
        }  <new_line>
        if ( $possible_error_message eq "" )  <new_line>
        {  <new_line>
            $global_nesting_level_of_file_actions ++ ;  <new_line>
            if ( $global_nesting_level_of_file_actions > 1 )  <new_line>
            {  <new_line>
                $possible_error_message .= " [warning, file-related action called recursivley, which is not allowed]" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $line_count = 1 ;  <new_line>
                while ( $input_line = <INFILE> )  <new_line>
                {  <new_line>
                    chomp( $input_line ) ;  <new_line>
                    $global_dashrep_replacement{ "linewise-input-line-from-file" } = $input_line ;  <new_line>
                    $global_dashrep_replacement{ "linewise-input-line-count" } = $line_count ;  <new_line>
                    $partial_translation = &dashrep_expand_parameters( $target_phrase_name );  <new_line>
                    $translation = &dashrep_expand_phrases( $partial_translation );  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-debug-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; after parameters expanded: " . $partial_translation . "}}\n" ;  <new_line>
                        $global_trace_log .= "{{trace; after phrases expanded: " . $partial_translation . "}}\n" ;  <new_line>
                    }  <new_line>
                    $global_nesting_level_of_file_actions -- ;  <new_line>
                    $line_count ++ ;  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; processed each line in file " . $source_filename . " using handler " . $target_phrase_name . "}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
            }  <new_line>
        }  <new_line>
        close( INFILE ) ;  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  End of branching.  <new_line>

    }  <new_line>


# no-space dashes-long-line  <new_line>
#  Handle the actions:  <new_line>
#  write-all-dashrep-definitions-to-file  <new_line>
#  write-dashrep-definitions-listed-in-phrase-to-file  <new_line>
#  <new_line>
#  The filename is edited to remove any path  <new_line>
#  specifications, and then the prefix in the  <new_line>
#  appropriate dashrep phrase is used.  <new_line>

    $definitions_or_phrase_names = "" ;  <new_line>
    if ( $action_name eq "write-dashrep-definitions-listed-in-phrase-to-file" )  <new_line>
    {  <new_line>
        if ( ( $source_phrase_name eq "" ) || ( $target_filename eq "" ) || ( $operand_two eq "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $source_phrase_name . " and " . $target_filename . " and " . $operand_two . "]" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $definitions_or_phrase_names = "definitions" ;  <new_line>
            @list_of_phrases = split( /[ \n\r]+/ , $global_dashrep_replacement{ $source_phrase_name } ) ;  <new_line>
            @sequence_of_phrases = @list_of_phrases ;  <new_line>
        }  <new_line>
    } elsif ( $action_name eq "write-all-dashrep-definitions-to-file" )  <new_line>
    {  <new_line>
        if ( ( $target_filename eq "" ) || ( $operand_two ne "" ) )  <new_line>
        {  <new_line>
            $possible_error_message .= " [warning, action " . $action_name . " has invalid operands " . $target_filename . " and " . $operand_two . "]" ;  <new_line>
        } else  <new_line>
        {  <new_line>
            $definitions_or_phrase_names = "definitions" ;  <new_line>
            @list_of_phrases = &dashrep_get_list_of_phrases( ) ;  <new_line>
            @sequence_of_phrases = sort( @list_of_phrases ) ;  <new_line>
            unshift( @sequence_of_phrases , "dashrep-language-yes" ) ;  <new_line>
        }  <new_line>
    }  <new_line>
    if ( $definitions_or_phrase_names ne "" )  <new_line>
    {  <new_line>
        if ( $#list_of_phrases < 0 )  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning: no phrases to write (to file)}}\n" ;  <new_line>
            }  <new_line>
        } else  <new_line>
        {  <new_line>
            $global_nesting_level_of_file_actions ++ ;  <new_line>
            if ( $global_nesting_level_of_file_actions > 1 )  <new_line>
            {  <new_line>
                $possible_error_message .= " [warning, file-related action called recursivley, which is not allowed]" ;  <new_line>
            } elsif ( $global_dashrep_replacement{ "yes-or-no-permission-to-delete-or-overwrite-files" } ne "yes" )  <new_line>
            {  <new_line>
                $possible_error_message .= " [warning, do not have permission to delete or overwrite files]" ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "yes-or-no-export-delimited-definitions" } eq "yes" )  <new_line>
            {  <new_line>
                if ( exists( $global_dashrep_replacement{ "export-defs-all-begin" } ) )  <new_line>
                {  <new_line>
                    $all_defs_begin = "[-export-defs-all-begin-]\n\n" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $all_defs_begin = "" ;  <new_line>
                }  <new_line>
                if ( exists( $global_dashrep_replacement{ "export-defs-all-end" } ) )  <new_line>
                {  <new_line>
                    $all_defs_end = "[-export-defs-all-end-]\n\n" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $all_defs_end = "" ;  <new_line>
                }  <new_line>
                if ( exists( $global_dashrep_replacement{ "export-defs-phrase-begin" } ) )  <new_line>
                {  <new_line>
                    $phrase_begin = "[-export-defs-phrase-begin-] " ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $phrase_begin = "" ;  <new_line>
                }  <new_line>
                if ( exists( $global_dashrep_replacement{ "export-defs-phrase-end" } ) )  <new_line>
                {  <new_line>
                    $phrase_end = " [-export-defs-phrase-end-]\n\n" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $phrase_end = "" ;  <new_line>
                }  <new_line>
                if ( exists( $global_dashrep_replacement{ "export-defs-def-begin" } ) )  <new_line>
                {  <new_line>
                    $def_begin = "[-export-defs-def-begin-] " ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $def_begin = "" ;  <new_line>
                }  <new_line>
                if ( exists( $global_dashrep_replacement{ "export-defs-def-end" } ) )  <new_line>
                {  <new_line>
                    $def_end = " [-export-defs-def-end-]\n\n" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $def_end = "" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $all_defs_begin = "dashrep-definitions-begin\n\n" ;  <new_line>
                $all_defs_end = "dashrep-definitions-end\n\n" ;  <new_line>
                $phrase_begin = "" ;  <new_line>
                $phrase_end = ":\n" ;  <new_line>
                $def_begin = "" ;  <new_line>
                $def_end = "\n-----\n\n" ;  <new_line>
            }  <new_line>
            if ( $possible_error_message eq "" )  <new_line>
            {  <new_line>
                if ( open ( OUTFILE , '>' . $target_filename ) )  <new_line>
                {  <new_line>
                    $possible_error_message .= "" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $possible_error_message .= " [warning, file named " . $target_filename . " could not be opened for writing]" ;  <new_line>
                }  <new_line>
                if ( $possible_error_message eq "" )  <new_line>
                {  <new_line>
                    $counter = 0 ;  <new_line>
                    if ( $definitions_or_phrase_names eq "definitions" )  <new_line>
                    {  <new_line>
                        print OUTFILE $all_defs_begin ;  <new_line>
                        foreach $phrase_name ( @sequence_of_phrases )  <new_line>
                        {  <new_line>
                            if ( ( defined( $phrase_name ) ) && ( $phrase_name =~ /^[^ ]+$/ ) && ( exists( $global_dashrep_replacement{ $phrase_name } ) ) && ( defined( $global_dashrep_replacement{ $phrase_name } ) ) && ( $phrase_name ne "four-hyphens" ) )  <new_line>
                            {  <new_line>
                                print OUTFILE $phrase_begin . $phrase_name . $phrase_end . $def_begin . $global_dashrep_replacement{ $phrase_name } . $def_end ;  <new_line>
                                $counter ++ ;  <new_line>
                            }  <new_line>
                        }  <new_line>
                        print OUTFILE $all_defs_end ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        foreach $phrase_name ( @sequence_of_phrases )  <new_line>
                        {  <new_line>
                            if ( ( defined( $phrase_name ) ) && ( $phrase_name =~ /[^ ]/ ) && ( exists( $global_dashrep_replacement{ $phrase_name } ) ) && ( $phrase_name ne "four-hyphens" ) )  <new_line>
                            {  <new_line>
                                print OUTFILE $phrase_name . "\n" ;  <new_line>
                                $counter ++ ;  <new_line>
                            }  <new_line>
                        }  <new_line>
                    }  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; wrote " . $counter . " " . $definitions_or_phrase_names . " to file: " . $target_filename . "}}\n" ;  <new_line>
                    }  <new_line>
                } else  <new_line>
                {  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
                    }  <new_line>
                }  <new_line>
                close( OUTFILE ) ;  <new_line>
                if ( not( chmod( $global_file_write_protection_mode , $target_filename ) ) )  <new_line>
                {  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; warning: protection of output file " . $target_filename . "  not successful}}\n" ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            $global_nesting_level_of_file_actions -- ;  <new_line>
        }  <new_line>
    }  <new_line>
#  end of action code  <new_line>


# no-space dashes-long-line  <new_line>
#  If there was an error message, put it  <new_line>
#  into the text that is returned as the  <new_line>
#  result.  <new_line>
#  Also, if requested, put the error message  <new_line>
#  into the trace log.  <new_line>

    $possible_error_message =~ s/^ +// ;  <new_line>
    $possible_error_message =~ s/ +$// ;  <new_line>
    if ( $possible_error_message =~ /[^ ]/ )  <new_line>
    {  <new_line>
        $action_result = " " . $possible_error_message . " " ;  <new_line>
        if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; warning: " . $possible_error_message . "}}\n" ;  <new_line>
        }  <new_line>
    }  <new_line>
    $possible_error_message = "" ;  <new_line>


# no-space dashes-long-line  <new_line>
#  Put the action result -- which is usually a  <new_line>
#  single space -- into the global output variable.  <new_line>

    $global_action_result = $action_result ;  <new_line>


# no-space dashes-long-line  <new_line>
#  Make the logged debugging (trace) information  <new_line>
#  available.  <new_line>

    $global_dashrep_replacement{ "dashrep-debug-trace-log" } .= $global_trace_log ;  <new_line>
    $global_trace_log = "" ;  <new_line>


# no-space dashes-long-line  <new_line>
#  Return.  <new_line>
#  The calling subroutine will return the value  <new_line>
#  of the "global_action_result" variable.  <new_line>

    return ;  <new_line>


# no-space dashes-long-line  <new_line>
#  End of subroutine.  <new_line>

}  <new_line>
