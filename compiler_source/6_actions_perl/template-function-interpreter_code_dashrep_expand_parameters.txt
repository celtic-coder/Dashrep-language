#***********************************************  <new_line>
#***********************************************  <new_line>
#       dashrep_expand_parameters  <new_line>
#***********************************************  <new_line>
#***********************************************  <new_line>

sub dashrep_expand_parameters  <new_line>
{  <new_line>

    my $undeleted_phrase_content ;  <new_line>
    my $do_nothing ;  <new_line>
    my $supplied_text ;  <new_line>
    my $replacement_text ;  <new_line>
    my $loop_status_done ;  <new_line>
    my $text_begin ;  <new_line>
    my $text_end ;  <new_line>
    my $text_parameter_content ;  <new_line>
    my $text_parameter_name ;  <new_line>
    my $text_parameter_value ;  <new_line>
    my $action_name ;  <new_line>
    my $operand_one ;  <new_line>
    my $operand_two ;  <new_line>
    my $operand_three ;  <new_line>
    my $operand_four ;  <new_line>
    my $operand_five ;  <new_line>
    my $operands_all ;  <new_line>
    my $action_result ;  <new_line>
    my $count ;  <new_line>
    my $yes_or_no ;  <new_line>
    my $text_parameter ;  <new_line>
    my $possible_new_limit ;  <new_line>
    my $source_phrase_name ;  <new_line>
    my $target_phrase_name ;  <new_line>
    my $epoch_seconds ;  <new_line>
    my $first_object_of_action ;  <new_line>
    my $second_object_of_action ;  <new_line>
    my $temp_text ;  <new_line>
    my $phrase_length ;  <new_line>
    my $counter ;  <new_line>
    my $value ;  <new_line>
    my $second_time ;  <new_line>
    my $minute ;  <new_line>
    my $hour ;  <new_line>
    my $day_of_month ;  <new_line>
    my $month_number ;  <new_line>
    my $year ;  <new_line>
    my $weekday ;  <new_line>
    my $day_of_year ;  <new_line>
    my $extra_info ;  <new_line>
    my $phrase_name ;  <new_line>
    my $starting_count ;  <new_line>
    my $ending_count ;  <new_line>
    my $plus_or_minus_one ;  <new_line>
    my $count_range ;  <new_line>
    my $next_number ;  <new_line>
    my $text_to_append ;  <new_line>
    my $output_list_one_phrase_name ;  <new_line>
    my $output_list_two_phrase_name ;  <new_line>
    my $input_list_one_phrase_name ;  <new_line>
    my $input_list_two_phrase_name ;  <new_line>
    my $input_list_one ;  <new_line>
    my $input_list_two ;  <new_line>
    my $count_list_one ;  <new_line>
    my $count_list_two ;  <new_line>
    my $counter_one ;  <new_line>
    my $value_one ;  <new_line>
    my $counter_two ;  <new_line>
    my $value_two ;  <new_line>
    my $separator_one ;  <new_line>
    my $separator_two ;  <new_line>
    my $numeric_value ;  <new_line>
    my $result_value ;  <new_line>
    my $character_to_replace ;  <new_line>
    my $character_position ;  <new_line>
    my $prefix ;  <new_line>
    my $suffix ;  <new_line>
    my $text_to_expand ;  <new_line>
    my $partial_translation ;  <new_line>
    my $translation ;  <new_line>
    my $word_to_find ;  <new_line>
    my $list_length ;  <new_line>
    my $last_pointer ;  <new_line>
    my $pointer ;  <new_line>
    my $text_list_loop ;  <new_line>
    my $text_list_key ;  <new_line>
    my $destination_phrase ;  <new_line>
    my $list_of_key_values ;  <new_line>
    my $listed_word ;  <new_line>
    my $word ;  <new_line>
    my $list_of_loop_words ;  <new_line>
    my $length_of_loop_list ;  <new_line>
    my $result_word_list ;  <new_line>
    my $string_in_phrase ;  <new_line>
    my $handler_phrase_name ;  <new_line>
    my $item_number ;  <new_line>
    my $phrase_words ;  <new_line>
    my $list_of_phrases ;  <new_line>
    my $sequence_of_phrases ;  <new_line>
    my $number_of_operands ;  <new_line>
    my $list_of_operands ;  <new_line>
    my $text_string ;  <new_line>
    my $source_text ;  <new_line>
    my $word_position ;  <new_line>
    my $list_of_words ;  <new_line>
    my $phrase_name_to_clear ;  <new_line>
    my $text_to_insert ;  <new_line>
    my $string_to_be_replaced ;  <new_line>
    my $word_number ;  <new_line>
    my $string_to_find ;  <new_line>
    my $string_to_search ;  <new_line>
    my $position ;  <new_line>
    my $result_text ;  <new_line>
    my $starting_character_position ;  <new_line>
    my $ending_character_position ;  <new_line>
    my $phrase_being_edited ;  <new_line>
    my $text_being_edited ;  <new_line>
    my $remaining_text ;  <new_line>
    my $accumulated_text ;  <new_line>
    my $possible_phrase_name ;  <new_line>
    my $length_of_string_to_be_replaced ;  <new_line>
    my $word_number_begin ;  <new_line>
    my $word_number_end ;  <new_line>
    my $word_count ;  <new_line>
    my $separator ;  <new_line>
    my $ending_first_count ;  <new_line>
    my $starting_second_count ;  <new_line>
    my $number_of_characters_to_get ;  <new_line>
    my $tracking_on_yes_or_no ;  <new_line>
    my $character_code_to_decode ;  <new_line>
    my $list_indicating_sort_order ;  <new_line>
    my $sort_order ;  <new_line>
    my $extra_words_without_sort_value ;  <new_line>
    my $length_of_string ;  <new_line>
    my $generated_list ;  <new_line>
    my $map_tile_zoom ;  <new_line>
    my $map_tile_n ;  <new_line>
    my $pi ;  <new_line>
    my $angle_in_radians ;  <new_line>
    my $sine_of_angle ;  <new_line>
    my $cosine_of_angle ;  <new_line>
    my $value_of_operand_one ;  <new_line>
    my $number_of_columns ;  <new_line>
    my $number_of_items ;  <new_line>
    my $number_of_items_in_bottom_row ;  <new_line>
    my $number_of_full_rows ;  <new_line>
    my $number_of_rows ;  <new_line>
    my $up_direction_minimum_value ;  <new_line>
    my $up_direction_maximum_value ;  <new_line>
    my $right_direction_minimum_value ;  <new_line>
    my $right_direction_maximum_value ;  <new_line>
    my $range_of_up_direction_values ;  <new_line>
    my $range_of_right_direction_values ;  <new_line>
    my $top_row_number ;  <new_line>
    my $bottom_row_number ;  <new_line>
    my $fill_direction_top_left ;  <new_line>
    my $fill_direction_bottom_right ;  <new_line>
    my $fill_direction_bottom_left ;  <new_line>
    my $fill_direction_top_right ;  <new_line>
    my $need_maximum ;  <new_line>
    my $need_minimum ;  <new_line>
    my $value_direction_right_and_up ;  <new_line>
    my $value_direction_left_and_up ;  <new_line>
    my $value_direction_up ;  <new_line>
    my $value_direction_right ;  <new_line>
    my $top_left_open_column ;  <new_line>
    my $top_right_open_column ;  <new_line>
    my $bottom_left_open_column ;  <new_line>
    my $bottom_right_open_column ;  <new_line>
    my $fill_direction ;  <new_line>
    my $target_row_number ;  <new_line>
    my $target_column_number ;  <new_line>
    my $need_maximum_or_minimum ;  <new_line>
    my $final_result ;  <new_line>
    my $row_number ;  <new_line>
    my $column_number ;  <new_line>
    my $next_value_to_compare ;  <new_line>
    my $use_value_direction ;  <new_line>
    my $max_or_min_value ;  <new_line>
    my $action_name_exists ;  <new_line>
    my $parameter_level ;  <new_line>
    my $parameter_begin_or_end_string ;  <new_line>
    my $phrase_type ;  <new_line>
    my $prefix_text ;  <new_line>
    my $list_of_words_as_text ;  <new_line>
    my $odd_or_even_based_on_zero_or_one ;  <new_line>
    my $item_number_at_min_or_max ;  <new_line>
    my $multiplier_for_up_direction_values ;  <new_line>
    my $multiplier_for_right_direction_values ;  <new_line>
    my $text_for_up_direction_values ;  <new_line>
    my $text_for_right_direction_values ;  <new_line>
    my $character_to_capitalize ;  <new_line>
    my $list_indicating_sort_order_text_string ;  <new_line>
    my $pointer_one ;  <new_line>
    my $pointer_two ;  <new_line>
    my $pointer_to_matching_text ;  <new_line>
    my $name_of_parameter_for_handler ;  <new_line>
    my $list_of_x_values_as_text ;  <new_line>
    my $list_of_y_values_as_text ;  <new_line>
    my $pair_pointer ;  <new_line>
    my $phrase_name_containing_source_words ;  <new_line>
    my $phrase_name_containing_pattern ;  <new_line>
    my $phrase_name_containing_parameter_list ;  <new_line>
    my $first_or_second ;  <new_line>
    my $segment_that_might_include_else ;  <new_line>
    my $remainder ;  <new_line>
    my $segment_if_first ;  <new_line>
    my $segment_if_second ;  <new_line>
    my $length_desired ;  <new_line>
    my $number_of_zeros_needed ;  <new_line>
    my $zero_padding ;  <new_line>
    my $single_value ;  <new_line>
    my $required_number_of_operands ;  <new_line>
    my $target_operand ;  <new_line>
    my $replacement_count ;  <new_line>
    my $endless_loop_replacements_with_count ;  <new_line>
    my $replacement_count_text ;  <new_line>
    my $search_starting_position ;  <new_line>
    my $list_of_positions ;  <new_line>
    my $local_endless_loop_counter ;  <new_line>
    my $local_endless_loop_counter_maximum ;  <new_line>
    my $repeat_count ;  <new_line>
    my $current_character_position_number ;  <new_line>
    my $character_pointer_to_next_word_zero_based ;  <new_line>
    my $growing_text_to_append ;  <new_line>
    my $words_to_find ;  <new_line>
    my $text_list_of_start_matching_positions ;  <new_line>
    my $list_of_text_items_to_find ;  <new_line>
    my $text_to_find_at_position ;  <new_line>
    my $number_of_items_to_find ;  <new_line>
    my $text_to_find ;  <new_line>
    my $position_of_text_found ;  <new_line>
    my $position_as_string ;  <new_line>
    my $paired_words_as_text ;  <new_line>
    my $pair_status ;  <new_line>
    my $pair_pointer_offset_zero ;  <new_line>
    my $string_to_insert ;  <new_line>
    my $position_end ;  <new_line>
    my $word_to_check ;  <new_line>
    my $string_to_match ;  <new_line>
    my $number_of_unique_words ;  <new_line>
    my $text_list_of_unique_word_counts ;  <new_line>
    my $number_of_items_remaining ;  <new_line>
    my $yes_or_no_within_ampersand_encoded_character ;  <new_line>
    my $octet_number ;  <new_line>
    my $unicode_number ;  <new_line>
    my $elapsed_time ;  <new_line>
    my $text_list_of_unique_word_pointers ;  <new_line>
    my @octet_number_at_position ;  <new_line>
    my @list_of_words_to_check ;  <new_line>
    my @list_of_strings_to_match ;  <new_line>
    my @list_of_paired_words ;  <new_line>
    my @item_number_found_at_position ;  <new_line>
    my @list_of_start_matching_positions ;  <new_line>
    my @list_of_phrase_names ;  <new_line>
    my @list_of_x_values ;  <new_line>
    my @list_of_y_values ;  <new_line>
    my @list ;  <new_line>
    my @list_of_sorted_numbers ;  <new_line>
    my @list_of_action_names ;  <new_line>
    my @zero_if_not_remaining_item_number ;  <new_line>
    my @right_and_up_direction_value_for_item_number ;  <new_line>
    my @left_and_up_direction_value_for_item_number ;  <new_line>
    my @column_position_for_item_number ;  <new_line>
    my @row_position_for_item_number ;  <new_line>
    my @list_of_remaining_item_numbers ;  <new_line>
    my @up_direction_value_for_item_number ;  <new_line>
    my @right_direction_value_for_item_number ;  <new_line>
    my @list_of_parameter_words ;  <new_line>
    my @list_of_source_words ;  <new_line>
    my @unique_word_at_position ;  <new_line>
    my %occurrence_count_for_word ;  <new_line>
    my %listed_word ;  <new_line>
    my %words_at_numeric_value ;  <new_line>
    my %item_number_at_row_column ;  <new_line>


#***********************************************  <new_line>
#  Get the hyphenated phrase or supplied string.  <new_line>

    if ( scalar( @_ ) == 1 )  <new_line>
    {  <new_line>
        $supplied_text = $_[ 0 ] ;  <new_line>
    } else  <new_line>
    {  <new_line>
        $supplied_text = "" ;  <new_line>
    }  <new_line>


#***********************************************  <new_line>
#  Use the supplied text as the default result,  <new_line>
#  without leading or trailing spaces.  <new_line>

    $replacement_text = $supplied_text ;  <new_line>
    $replacement_text =~ s/[\r\n\t]/ /sg ;  <new_line>
    $replacement_text =~ s/^ +// ;  <new_line>
    $replacement_text =~ s/ +$// ;  <new_line>


#***********************************************  <new_line>
#  If there is no supplied text and no  <new_line>
#  runtime-code action name, return with nothing.  <new_line>

    if ( ( $supplied_text eq "" ) && ( $global_single_action_name eq "" ) )  <new_line>
    {  <new_line>
        return $replacement_text ;  <new_line>
    }  <new_line>


#***********************************************  <new_line>
#  If just a hyphenated phrase was supplied,  <new_line>
#  expand it into its replacement text.  <new_line>

    if ( $supplied_text =~ /^ *([^\- ]+-[^ ]*[^\- ]) *$/ )  <new_line>
    {  <new_line>
        $supplied_text = $1 ;  <new_line>
        if ( ( exists( $global_dashrep_replacement{ $supplied_text } ) ) && ( $global_dashrep_replacement{ $supplied_text } =~ /[^ ]/ ) )  <new_line>
        {  <new_line>
            $replacement_text = $global_dashrep_replacement{ $supplied_text } ;  <new_line>
        }  <new_line>
    }  <new_line>


#***********************************************  <new_line>
#  Update the endless loop count limit in case  <new_line>
#  it has changed.  <new_line>

    if ( $global_dashrep_replacement{ "dashrep-endless-loop-counter-limit" } =~ /^[0-9]+$/ )  <new_line>
    {  <new_line>
        $possible_new_limit = $global_dashrep_replacement{ "dashrep-endless-loop-counter-limit" } + 0 ;  <new_line>
        if ( ( $possible_new_limit != $global_endless_loop_counter_limit ) && ( $possible_new_limit > 1000 ) )  <new_line>
        {  <new_line>
            $global_endless_loop_counter_limit = $possible_new_limit ;  <new_line>
            if ( ( $global_dashrep_replacement{ "dashrep-debug-trace-on-yes-or-no" } eq "yes" ) && ( $replacement_text =~ /[^ ]/ ) )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; updated endless loop counter limit: " . $possible_new_limit . "}}\n";  <new_line>
            }  <new_line>
        }  <new_line>
    }  <new_line>


#***********************************************  <new_line>
#  Update the time limit in case it has changed.  <new_line>

    if ( $global_dashrep_replacement{ "dashrep-time-limit" } =~ /^[0-9]+$/ )  <new_line>
    {  <new_line>
        $possible_new_limit = $global_dashrep_replacement{ "dashrep-time-limit" } + 0 ;  <new_line>
        if ( ( $possible_new_limit != $global_time_limit ) && ( $possible_new_limit > 0 ) )  <new_line>
        {  <new_line>
            $global_time_limit = $possible_new_limit ;  <new_line>
            if ( ( $global_dashrep_replacement{ "dashrep-debug-trace-on-yes-or-no" } eq "yes" ) && ( $replacement_text =~ /[^ ]/ ) )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; updated time limit: " . $possible_new_limit . "}}\n";  <new_line>
            }  <new_line>
        }  <new_line>
    }  <new_line>


#***********************************************  <new_line>
#  Begin a loop that repeats until there have  <new_line>
#  been no more replacements.  <new_line>

    $loop_status_done = $global_false ;  <new_line>
    while ( $loop_status_done == $global_false )  <new_line>
    {  <new_line>
        $loop_status_done = $global_true ;  <new_line>

        if ( ( $global_dashrep_replacement{ "dashrep-debug-trace-on-yes-or-no" } eq "yes" ) && ( $replacement_text =~ /[^ ]/ ) )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; replacement string: " . $replacement_text . "}}\n";  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Stop translating if requested.  <new_line>

        if ( $global_dashrep_replacement{ "dashrep-stop-translation" } eq "yes" )  <new_line>
        {  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-debug-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; stopping translation as requested}}\n";  <new_line>
            }  <new_line>
            last ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Check for an endless loop.  <new_line>

        $global_endless_loop_counter ++ ;  <new_line>
        $global_replacement_count_for_item_name{ "expand parameters subroutine" } ++ ;  <new_line>
        if ( $global_endless_loop_counter > $global_endless_loop_counter_limit )  <new_line>
        {  <new_line>
            &handle_endless_loop_encountered( ) ;  <new_line>
            $global_dashrep_replacement{ "dashrep-stop-translation" } = "yes" ;  <new_line>
            $global_trace_log .= "{{trace; Error: The dashrep_expand_parameters subroutine has encountered an endless loop, so attempting to stop translation gently}}\n";  <new_line>
            last ;  <new_line>
        }  <new_line>
        if ( $global_endless_loop_counter > ( $global_endless_loop_counter_limit + 100 ) )  <new_line>
        {  <new_line>
#  remove-from-cpan-version-begin  <new_line>
            warn "Warning: The dashrep_expand_parameters subroutine has encountered an endless loop." . "\n" . "Stopped" ;  <new_line>
#  remove-from-cpan-version-end  <new_line>
#  uncomment-for-cpan-version-begin  <new_line>
#            carp "Warning: The dashrep_expand_parameters subroutine has encountered an endless loop." . "\n" . "Stopped" ;  <new_line>
#  uncomment-for-cpan-version-end  <new_line>
            return 0 ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Check if time limit exceeded.  <new_line>

        $global_interval_count_for_time_limit_check ++ ;  <new_line>
        if ( $global_interval_count_for_time_limit_check > 1000 )  <new_line>
        {  <new_line>
            $global_interval_count_for_time_limit_check = 0 ;  <new_line>
            $elapsed_time = time - $global_starting_time ;  <new_line>
            if ( $elapsed_time > $global_time_limit )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ "dashrep-stop-translation" } = "yes" ;  <new_line>
                $global_trace_log .= "{{trace; Error: The dashrep_expand_parameters subroutine has exceeded the time limit, so attempting to stop translation gently}}\n";  <new_line>
                last ;  <new_line>
            }  <new_line>
            if ( $elapsed_time > ( $global_time_limit + 1 ) )  <new_line>
            {  <new_line>
#  remove-from-cpan-version-begin  <new_line>
                warn "Warning: The dashrep_expand_parameters subroutine has exceeded the time limit." . "\n" . "Stopped" ;  <new_line>
#  remove-from-cpan-version-end  <new_line>
#  uncomment-for-cpan-version-begin  <new_line>
#                carp "Warning: The dashrep_expand_parameters subroutine has exceeded the time limit." . "\n" . "Stopped" ;  <new_line>
#  uncomment-for-cpan-version-end  <new_line>
                return 0 ;  <new_line>
            }  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Get the next inner-most parameter syntax --  <new_line>
#  with "[-" at the beginning and "-]" at the end.  <new_line>
#  (It must not contain a nested parameter syntax.)  <new_line>
#  If it contains any line breaks, replace those  <new_line>
#  with spaces.  If there are no more parameters,  <new_line>
#  exit the loop.  <new_line>
#  <new_line>
#  ToDo:  Finish editing and testing code to  <new_line>
#  also handle words:  <new_line>
#  ambee amenn fenambee amennfen  <new_line>

        if ( $replacement_text =~ /((ambee)|(amenn)|(fenambee)|(amennfen))/ )  <new_line>
        {  <new_line>
            $replacement_text =~ s/((^)|( +))fenambee(( +)|($))/-\[-/sgi ;  <new_line>
            $replacement_text =~ s/((^)|( +))amennfen(( +)|($))/-\]-/sgi ;  <new_line>
            $replacement_text =~ s/((^)|( +))ambee(( +)|($))/\[-/sgi ;  <new_line>
            $replacement_text =~ s/((^)|( +))amenn(( +)|($))/-\]/sgi ;  <new_line>
        }  <new_line>
        $text_begin = "" ;  <new_line>
        $text_parameter_content = "" ;  <new_line>
        $text_end = "" ;  <new_line>
        if ( $replacement_text =~ /^(.*?)\[\-([^\[\]]*)\-\](.*)$/ )  <new_line>
        {  <new_line>
            $text_begin = $1 ;  <new_line>
            $text_parameter_content = $2 ;  <new_line>
            $text_end = $3 ;  <new_line>
        }  <new_line>
        if ( ( $text_parameter_content eq "" ) && ( $global_single_action_name eq "" ) )  <new_line>
        {  <new_line>
            last ;  <new_line>
        }  <new_line>
        $text_parameter_content =~ s/[\r\n\t]/ /sg ;  <new_line>
        $text_parameter_content =~ s/^ +// ;  <new_line>
        $text_parameter_content =~ s/ +$// ;  <new_line>
        $loop_status_done = $global_false ;  <new_line>
        if ( ( $global_dashrep_replacement{ "dashrep-debug-trace-on-yes-or-no" } eq "yes" ) && ( $text_parameter_content =~ /[^ ]/ ) )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; innermost parameter: " . $text_parameter_content . "}}\n";  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  If there is a parameter value assigned -- as  <new_line>
#  indicated by an equal sign -- then assign  <new_line>
#  the value, and restart the main loop.  <new_line>
#  The parameter value cannot contain a line break.  <new_line>

        if ( $text_parameter_content =~ /^ *([^ \:=\-]+\-[^ \:=]+) *= *([^ ](.*[^ ])?) *$/ )  <new_line>
        {  <new_line>
            $text_parameter_name = $1 ;  <new_line>
            $text_parameter_value = $2 ;  <new_line>
            $text_parameter_value =~ s/[\- ]+$// ;  <new_line>
            if ( ( length( $text_parameter_name ) > 0 ) && ( $text_parameter_name =~ /^[^\-]+-/ ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $text_parameter_name } = $text_parameter_value ;  <new_line>
            }  <new_line>
            $replacement_text = $text_begin . " " . $text_end ;  <new_line>
            $global_replacement_count_for_item_name{ $text_parameter_value } ++ ;  <new_line>
            $global_replacement_count_for_item_name{ "expand parameters subroutine" } -- ;  <new_line>
            if ( $global_replacement_count_for_item_name{ $text_parameter_value } == 1 )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ "list-of-phrases-newly-defined" } .= " " . $text_parameter_name ;  <new_line>
            }  <new_line>
            if ( ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" ) && ( $text_parameter_name =~ /[^ ]/ ) )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; assignment: " . $text_parameter_name . " = " . $text_parameter_value . "}}\n";  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  If the parameter is a defined phrase, do the  <new_line>
#  replacement, then restart the main loop.  <new_line>
#  Use the "dashrep-recent-phrase-name-replaced"  <new_line>
#  phrase as a way to access this replacement  <new_line>
#  name for debugging purposes.  <new_line>

        if ( ( $text_parameter_content ne "" ) && ( $text_parameter_content !~ / / ) && ( exists( $global_dashrep_replacement{ $text_parameter_content } ) ) )  <new_line>
        {  <new_line>
            if ( defined( $global_dashrep_replacement{ $text_parameter_content } ) )  <new_line>
            {  <new_line>
                $text_parameter = $global_dashrep_replacement{ $text_parameter_content } ;  <new_line>
                if ( $text_parameter =~ /[^ ]/ )  <new_line>
                {  <new_line>
                    $replacement_text = $text_begin . $text_parameter . $text_end ;  <new_line>
                    $global_replacement_count_for_item_name{ $text_parameter_content } ++ ;  <new_line>
                    $global_replacement_count_for_item_name{ "expand parameters subroutine" } -- ;  <new_line>
                    $loop_status_done = $global_false ;  <new_line>
                    $global_dashrep_replacement{ "dashrep-recent-phrase-name-replaced" } = $text_parameter_content ;  <new_line>
                    if ( ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" ) && ( $text_parameter_content =~ /[^ ]/ ) )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; replaced " . $text_parameter_content . " with its definition" . "}}\n";  <new_line>
                    }  <new_line>
                } else  <new_line>
                {  <new_line>
                    $replacement_text = $text_begin . " " . $text_end ;  <new_line>
                    $loop_status_done = $global_false ;  <new_line>
                    $global_replacement_count_for_item_name{ "undefined or empty parameter named " . $text_parameter_content } ++ ;  <new_line>
                    $global_replacement_count_for_item_name{ "expand parameters subroutine" } -- ;  <new_line>
                    if ( ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" ) && ( $text_parameter_content =~ /[^ ]/ ) )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; phrase " . $text_parameter . " is empty, so replaced with single space" . "}}\n";  <new_line>
                    }  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . " " . $text_end ;  <new_line>
                $loop_status_done = $global_false ;  <new_line>
                if ( ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" ) && ( $text_parameter_content =~ /[^ ]/ ) )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; phrase " . $text_parameter . " exists but is not defined, so it may be empty, so replaced with single space" . "}}\n";  <new_line>
                }  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  If a colon follows the action name (or any  <new_line>
#  phrase name at the beginning), replace it with  <new_line>
#  a space.  <new_line>

        $text_parameter_content =~ s/^([^ \:]+-[^ \:]+) *:/$1 /sg ;  <new_line>


#***********************************************  <new_line>
#  Replace any tabs with spaces, and replace  <new_line>
#  multiple adjacent spaces with a single space,  <new_line>
#  and remove leading and trailing spaces.  <new_line>

        $text_parameter_content =~ s/\t+/ /g ;  <new_line>
        $text_parameter_content =~ s/  +/ /g ;  <new_line>
        $text_parameter_content =~ s/^ // ;  <new_line>
        $text_parameter_content =~ s/ $// ;  <new_line>


#***********************************************  <new_line>
#  If this subroutine is being used as runtime  <new_line>
#  code for compiled code, get the single action  <new_line>
#  name and its operands.  <new_line>

        if ( $global_single_action_name ne "" )  <new_line>
        {  <new_line>
            $loop_status_done = $global_true ;  <new_line>
            $action_name = $global_single_action_name ;  <new_line>
            $operands_all = $global_single_action_operands_all ;  <new_line>
            if ( exists( $global_required_number_of_operands_for_action{ $action_name } ) )  <new_line>
            {  <new_line>
                $number_of_operands = $global_required_number_of_operands_for_action{ $action_name } ;  <new_line>
            } elsif ( exists( $global_minimum_number_of_operands_for_action{ $action_name } ) )  <new_line>
            {  <new_line>
                $number_of_operands = $global_minimum_number_of_operands_for_action{ $action_name } ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $number_of_operands = 0 ;  <new_line>
            }  <new_line>


# added 2017may24  <new_line>
            $operand_two = '' ;  <new_line>


            if ( $number_of_operands > 0 )  <new_line>
            {  <new_line>
                $operand_one = $global_single_action_operand_one ;  <new_line>
                if ( $number_of_operands > 1 )  <new_line>
                {  <new_line>
                    $operand_two = $global_single_action_operand_two ;  <new_line>
                    if ( $number_of_operands > 2 )  <new_line>
                    {  <new_line>
                        $operand_three = $global_single_action_operand_three ;  <new_line>
                        if ( $number_of_operands > 3 )  <new_line>
                        {  <new_line>
                            $operand_four = $global_single_action_operand_four ;  <new_line>
                            if ( $number_of_operands > 4 )  <new_line>
                            {  <new_line>
                                $operand_five = $global_single_action_operand_five ;  <new_line>
                            }  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-debug-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; single action info: " . $global_single_action_name . " , " . $global_single_action_operand_one . " , " . $global_single_action_operand_two . " , " . $global_single_action_operand_three . " , " . $global_single_action_operand_four . "}}\n" ;  <new_line>
            }  <new_line>


#***********************************************  <new_line>
#  From the current "text parameter content"  <new_line>
#  get the action name and the operands.  If there  <new_line>
#  are no non-space characters, remove the  <new_line>
#  parameter brackets and restart the main loop.  <new_line>

        } else  <new_line>
        {  <new_line>
            $operands_all = "" ;  <new_line>
            $operand_one = "" ;  <new_line>
            $operand_two = "" ;  <new_line>
            $operand_three = "" ;  <new_line>
            $operand_four = "" ;  <new_line>
            $operand_five = "" ;  <new_line>
            $number_of_operands = 0 ;  <new_line>
            if ( $text_parameter_content =~ /^([^ ]+)(.*)$/ )  <new_line>
            {  <new_line>
                $action_name = $1 ;  <new_line>
                $operands_all = $2 ;  <new_line>
                $action_name =~ s/^\-+// ;  <new_line>
                $action_name =~ s/\-+$// ;  <new_line>
                $operands_all =~ s/\n/ /sg ;  <new_line>
                $operands_all =~ s/^ +// ;  <new_line>
                $operands_all =~ s/ +$// ;  <new_line>
                $operands_all =~ s/\-+$// ;  <new_line>
                @list_of_operands = split( / +/ , $operands_all ) ;  <new_line>
                $number_of_operands = scalar( @list_of_operands ) ;  <new_line>
                if ( $number_of_operands >= 1 )  <new_line>
                {  <new_line>
                    $operand_one = $list_of_operands[ 0 ] ;  <new_line>
                }  <new_line>
                if ( $number_of_operands >= 2 )  <new_line>
                {  <new_line>
                    $operand_two = $list_of_operands[ 1 ] ;  <new_line>
                }  <new_line>
                if ( $number_of_operands >= 3 )  <new_line>
                {  <new_line>
                    $operand_three = $list_of_operands[ 2 ] ;  <new_line>
                }  <new_line>
                if ( $number_of_operands >= 4 )  <new_line>
                {  <new_line>
                    $operand_four = $list_of_operands[ 3 ] ;  <new_line>
                }  <new_line>
                if ( $number_of_operands >= 5 )  <new_line>
                {  <new_line>
                    $operand_five = $list_of_operands[ 4 ] ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . " " . $text_parameter_content . " " . $text_end ;  <new_line>
                next ;  <new_line>
            }  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  If the action name is not recognized, leave  <new_line>
#  the text as-is, but omit the brackets,  <new_line>
#  and indicate this situation, which is not  <new_line>
#  necessarily an error.  <new_line>

        if ( ( not( exists( $global_required_number_of_operands_for_action{ $action_name } ) ) ) && ( not( ( exists( $global_minimum_number_of_operands_for_action{ $action_name } ) ) ) ) )  <new_line>
        {  <new_line>
            $replacement_text = $text_begin . $text_parameter_content . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, first word in parameter brackets is not a recognized action name: " . $action_name . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Keep track of some info.  <new_line>

        if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; action " . $action_name . " has " . $number_of_operands . " operands: " . $operands_all . "}}\n";  <new_line>
        }  <new_line>
        $global_replacement_count_for_item_name{ "action " . $action_name } ++ ;  <new_line>
        $global_replacement_count_for_item_name{ "text parameter content " . $text_parameter_content } ++ ;  <new_line>
        $global_replacement_count_for_item_name{ "expand parameters subroutine" } -- ;  <new_line>


#***********************************************  <new_line>
#  Check the number of operands.  If not correct,  <new_line>
#  do not execute the action.  <new_line>

        if ( ( exists( $global_required_number_of_operands_for_action{ $action_name } ) ) && ( $global_required_number_of_operands_for_action{ $action_name } != $number_of_operands ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, wrong number of operands (" . $number_of_operands . ") for action " . $action_name . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( exists( $global_minimum_number_of_operands_for_action{ $action_name } ) ) && ( $number_of_operands < $global_minimum_number_of_operands_for_action{ $action_name } ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, not enough operands for action " . $action_name . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Check some operands.  If not valid,  <new_line>
#  do not execute the action.  <new_line>

        if ( ( ( exists( $global_check_operand_one_phrase_is_not_empty_for_action{ $action_name } ) ) ) && ( ( not( exists( $global_dashrep_replacement{ $operand_one } ) ) ) || ( $global_dashrep_replacement{ $operand_one } eq "" ) ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand one (" . $operand_one . ") does not exist, or is empty" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( ( exists( $global_check_operand_two_phrase_is_not_empty_for_action{ $action_name } ) ) ) && ( ( not( exists( $global_dashrep_replacement{ $operand_two } ) ) ) || ( $global_dashrep_replacement{ $operand_two } eq "" ) ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand two (" . $operand_two . ") does not exist, or is empty" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( ( exists( $global_check_operand_one_is_positive_integer_for_action{ $action_name } ) ) ) && ( $operand_one !~ /^[0-9]+$/ ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand one (" . $operand_one . ") is not a positive integer" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( ( exists( $global_check_operand_two_is_positive_integer_for_action{ $action_name } ) ) ) && ( $operand_two !~ /^[0-9]+$/ ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand two (" . $operand_two . ") is not a positive integer" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( ( exists( $global_check_operand_three_is_positive_integer_for_action{ $action_name } ) ) ) && ( $operand_three !~ /^[0-9]+$/ ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand three (" . $operand_three . ") is not a positive integer" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( ( exists( $global_check_operand_one_is_real_number_for_action{ $action_name } ) ) ) && ( $operand_one !~ /^[\-\+0-9\.]+$/ ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand one (" . $operand_one . ") is not a real number" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( ( exists( $global_check_operand_two_is_real_number_for_action{ $action_name } ) ) ) && ( $operand_two !~ /^[\-\+0-9\.]+$/ ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand two (" . $operand_two . ") is not a real number" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( exists( $global_check_operand_one_is_phrase_name_for_action{ $action_name } ) ) && ( ( $operand_one =~ /^[\-]/ ) || ( $operand_one =~ /[\-]$/ ) ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand one (" . $operand_one . ") is not a valid phrase name" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( exists( $global_check_operand_two_is_phrase_name_for_action{ $action_name } ) ) && ( ( $operand_two =~ /^[\-]/ ) || ( $operand_two =~ /[\-]$/ ) ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand two (" . $operand_two . ") is not a valid phrase name" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( exists( $global_check_operand_three_is_phrase_name_for_action{ $action_name } ) ) && ( ( $operand_three =~ /^[\-]/ ) || ( $operand_three =~ /[\-]$/ ) ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand three (" . $operand_three . ") is not a valid phrase name" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( exists( $global_check_operand_four_is_phrase_name_for_action{ $action_name } ) ) && ( ( $operand_four =~ /^[\-]/ ) || ( $operand_four =~ /[\-]$/ ) ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand four (" . $operand_four . ") is not a valid phrase name" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( exists( $global_check_operand_one_is_file_name_for_action{ $action_name } ) ) && ( $operand_one !~ /^[^ ]+\.[^ ]+/ ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand one (" . $operand_one . ") is not a valid file name" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>
        if ( ( exists( $global_check_operand_two_is_file_name_for_action{ $action_name } ) ) && ( $operand_two !~ /^[^ ]+\.[^ ]+/ ) )  <new_line>
        {  <new_line>
            $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand two (" . $operand_two . ") is not a valid file name" . "}}\n" ;  <new_line>
            }  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Clear the result text.  <new_line>
#  Include a space so that if this result is  <new_line>
#  inserted between phrases, the phrases will not  <new_line>
#  be joined.  <new_line>

        $action_result = " " ;  <new_line>


#***********************************************  <new_line>
#  If requested, log the action details.  <new_line>

        if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; starting action " . $action_name . " with operands: " . $operand_one . " and " . $operand_two . " and " . $operand_three . " and " . $operand_four . " and " . $operand_five . "}}\n" ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Beginning of code for actions.  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  clear-phrase  <new_line>

        if ( $action_name eq "clear-phrase" )  <new_line>
        {  <new_line>
            $phrase_name = $operand_one ;  <new_line>
            $global_dashrep_replacement{ $phrase_name } = "" ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; cleared phrase " . $phrase_name . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  clear-listed-phrases  <new_line>
#  delete-listed-phrases  <new_line>

        if ( ( $action_name eq "clear-listed-phrases" ) || ( $action_name eq "delete-listed-phrases" ) )  <new_line>
        {  <new_line>
            $phrase_name = $operand_one ;  <new_line>
            @list_of_phrase_names = split( / + / , $global_dashrep_replacement{ $phrase_name } ) ;  <new_line>
            foreach $phrase_name_to_clear ( @list_of_phrase_names )  <new_line>
            {  <new_line>
                if ( exists( $global_dashrep_replacement{ $phrase_name_to_clear } ) )  <new_line>
                {  <new_line>
                    if ( $action_name eq "delete-listed-phrases" )  <new_line>
                    {  <new_line>
                        delete( $global_dashrep_replacement{ $phrase_name_to_clear } ) ;  <new_line>
                    } elsif ( $action_name eq "clear-listed-phrases" )  <new_line>
                    {  <new_line>
                        $global_dashrep_replacement{ $phrase_name_to_clear } = "" ;  <new_line>

                        $global_trace_log .= "{{trace; cleared phrase " . $phrase_name_to_clear . "}}\n" ;  <new_line>

                    }  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                if ( $action_name eq "delete-listed-phrases" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; deleted phrases listed in phrase " . $phrase_name . "}}\n" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; cleared phrases listed in phrase " . $phrase_name . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  delete-all-dashrep-phrases  <new_line>

        if ( $action_name eq "delete-all-dashrep-phrases" )  <new_line>
        {  <new_line>
            $tracking_on_yes_or_no = $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } ;  <new_line>
            $undeleted_phrase_content = "" ;  <new_line>
            if ( ( exists( $global_dashrep_replacement{ "undeleted-phrase" } ) ) && ( $global_dashrep_replacement{ "undeleted-phrase" } =~ /[^ ]/ ) )  <new_line>
            {  <new_line>
                $undeleted_phrase_content = $global_dashrep_replacement{ "undeleted-phrase" } ;  <new_line>
            }  <new_line>
            &dashrep_delete_all( );  <new_line>
            if ( $undeleted_phrase_content ne "" )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ "undeleted-phrase" } = $undeleted_phrase_content ;  <new_line>
            }  <new_line>
            if ( $tracking_on_yes_or_no eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; cleared all definitions, including tracking/trace settings}}\n" ;  <new_line>
            }  <new_line>
            $global_endless_loop_counter = 0 ;  <new_line>
            $replacement_text = " " ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  append-text  <new_line>
#  append-text-no-space  <new_line>
#  prepend-text  <new_line>
#  prepend-text-no-space  <new_line>
#  append-repeatedly-using-count  <new_line>

        if ( ( $action_name eq "append-text" ) || ( $action_name eq "append-text-no-space" ) || ( $action_name eq "prepend-text" ) || ( $action_name eq "prepend-text-no-space" ) || ( $action_name eq "append-repeatedly-using-count" ) )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $text_to_append = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            } else  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; action " . $action_name . " has nothing to append, because operand one -- " . $operand_one . " -- is empty" . "}}\n" ;  <new_line>
                }  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                next ;  <new_line>
            }  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $operand_two } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $operand_two } = "" ;  <new_line>
            }  <new_line>
            if ( $action_name eq "append-text-no-space" )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $operand_two } .= $text_to_append ;  <new_line>
            } elsif ( $action_name eq "prepend-text-no-space" )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $operand_two } = $text_to_append . $global_dashrep_replacement{ $operand_two } ;  <new_line>
            } elsif ( $action_name eq "append-text" )  <new_line>
            {  <new_line>
                $text_to_append =~ s/^ +//s ;  <new_line>
                $text_to_append =~ s/ +$//s ;  <new_line>
                if ( $global_dashrep_replacement{ $operand_two } eq "" )  <new_line>
                {  <new_line>
                    $global_dashrep_replacement{ $operand_two } = $text_to_append ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $global_dashrep_replacement{ $operand_two } .= " " . $text_to_append ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "prepend-text" )  <new_line>
            {  <new_line>
                $text_to_append =~ s/^ +//s ;  <new_line>
                $text_to_append =~ s/ +$//s ;  <new_line>
                if ( $global_dashrep_replacement{ $operand_two } eq "" )  <new_line>
                {  <new_line>
                    $global_dashrep_replacement{ $operand_two } = $text_to_append ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $global_dashrep_replacement{ $operand_two } = $text_to_append . " " . $global_dashrep_replacement{ $operand_two } ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "append-repeatedly-using-count" )  <new_line>
            {  <new_line>
                $text_to_append =~ s/^ +//s ;  <new_line>
                $text_to_append =~ s/ +$//s ;  <new_line>
                if ( $operand_three eq "0" )  <new_line>
                {  <new_line>
                    $repeat_count = 0 ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $repeat_count = $operand_three + 0 ;  <new_line>
                }  <new_line>
                if ( ( $repeat_count < 1 ) || ( $repeat_count > 99999 ) )  <new_line>
                {  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; action " . $action_name . " has repeat count (" . $repeat_count . ") that is less than one or is too large" . "}}\n" ;  <new_line>
                    }  <new_line>
                    $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                    next ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $growing_text_to_append = "" ;  <new_line>
                    if ( $global_dashrep_replacement{ $operand_two } eq "" )  <new_line>
                    {  <new_line>
                        $growing_text_to_append = $text_to_append ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        $growing_text_to_append = " " . $text_to_append ;  <new_line>
                    }  <new_line>
                    for ( $count = 2 ; $count <= $repeat_count ; $count ++ )  <new_line>
                    {  <new_line>
                        $growing_text_to_append .= " " . $text_to_append ;  <new_line>
                    }  <new_line>
                    $global_dashrep_replacement{ $operand_two } .= $growing_text_to_append ;  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; did action " . $action_name . " from phrase " . $operand_one . " to phrase " . $operand_two . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  append-new-line  <new_line>

        if ( $action_name eq "append-new-line" )  <new_line>
        {  <new_line>
            $global_dashrep_replacement{ $operand_one } .= "\n" ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; appended newline to phrase " . $operand_one . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  copy-listed-words-to-phrases-named-in-pattern  <new_line>
#  append-multiple-from-phrases-named-in-pattern  <new_line>

        if ( ( $action_name eq "copy-listed-words-to-phrases-named-in-pattern" ) || ( $action_name eq "append-multiple-from-phrases-named-in-pattern" ) )  <new_line>
        {  <new_line>
            if ( $action_name eq "copy-listed-words-to-phrases-named-in-pattern" )  <new_line>
            {  <new_line>
                $phrase_name_containing_source_words = $operand_one ;  <new_line>
                $phrase_name_containing_pattern = $operand_two ;  <new_line>
                $target_phrase_name = "" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $phrase_name_containing_pattern = $operand_one ;  <new_line>
                $target_phrase_name = $operand_two ;  <new_line>
                $phrase_name_containing_source_words = "" ;  <new_line>
            }  <new_line>
            if ( ( defined( $global_dashrep_replacement{ $phrase_name_containing_pattern } ) ) && ( $global_dashrep_replacement{ $phrase_name_containing_pattern } =~ /^([^ ]*)ambee-([^ ]*)-amenn([^ ]*)$/ ) )  <new_line>
            {  <new_line>
                $prefix = $1 ;  <new_line>
                $phrase_name_containing_parameter_list = $2 ;  <new_line>
                $suffix = $3 ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , invalid operand: " . $phrase_name_containing_pattern . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            $prefix =~ s/[ \n]+//g ;  <new_line>
            $prefix =~ s/^-+// ;  <new_line>
            $suffix =~ s/[ \n]+//g ;  <new_line>
            $suffix =~ s/-+$// ;  <new_line>
            $phrase_name_containing_parameter_list =~ s/[ \n]+//g ;  <new_line>
            $phrase_name_containing_parameter_list =~ s/^-+// ;  <new_line>
            $phrase_name_containing_parameter_list =~ s/-+$// ;  <new_line>
            if ( not( defined( $global_dashrep_replacement{ $phrase_name_containing_parameter_list } ) ) )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , the operand " . $phrase_name_containing_parameter_list . " is not defined, so nothing was done" . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            $list_of_words_as_text = $global_dashrep_replacement{ $phrase_name_containing_parameter_list } ;  <new_line>
            $list_of_words_as_text =~ s/\n/ /sg ;  <new_line>
            $list_of_words_as_text =~ s/^ +// ;  <new_line>
            $list_of_words_as_text =~ s/ +$// ;  <new_line>
            if ( $list_of_words_as_text !~ /[^ ]/ )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , the operand " . $phrase_name_containing_parameter_list . " does not contain any words, so nothing was done" . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            @list_of_parameter_words = split( / +/ , $list_of_words_as_text ) ;  <new_line>
            if ( $action_name eq "copy-listed-words-to-phrases-named-in-pattern" )  <new_line>
            {  <new_line>
                $phrase_name_containing_source_words =~ s/[ \n]+//sg ;  <new_line>
                $phrase_name_containing_source_words =~ s/^-+// ;  <new_line>
                $phrase_name_containing_source_words =~ s/-+$// ;  <new_line>
                if ( not( defined( $global_dashrep_replacement{ $phrase_name_containing_source_words } ) ) )  <new_line>
                {  <new_line>
                    $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; warning, for action " . $action_name . " , the operand " . $phrase_name_containing_source_words . " is not defined, so no copying was done" . "}}\n" ;  <new_line>
                    }  <new_line>
                    next ;  <new_line>
                }  <new_line>
                $list_of_words_as_text = $global_dashrep_replacement{ $phrase_name_containing_source_words } ;  <new_line>
                $list_of_words_as_text =~ s/\n/ /sg ;  <new_line>
                $list_of_words_as_text =~ s/^ +// ;  <new_line>
                $list_of_words_as_text =~ s/ +$// ;  <new_line>
                if ( $list_of_words_as_text !~ /[^ ]/ )  <new_line>
                {  <new_line>
                    $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; warning, for action " . $action_name . " , the operand " . $phrase_name_containing_source_words . " does not contain any words, so no copying was done" . "}}\n" ;  <new_line>
                    }  <new_line>
                    next ;  <new_line>
                }  <new_line>
                @list_of_source_words = split( / +/ , $list_of_words_as_text ) ;  <new_line>
            }  <new_line>
            if ( $action_name eq "copy-listed-words-to-phrases-named-in-pattern" )  <new_line>
            {  <new_line>
                for ( $pointer = 0 ; $pointer <= $#list_of_parameter_words ; $pointer ++ )  <new_line>
                {  <new_line>
                    if ( $pointer <= $#list_of_source_words )  <new_line>
                    {  <new_line>
                        $target_phrase_name = $prefix . $list_of_parameter_words[ $pointer ] . $suffix ;  <new_line>
                        if ( $target_phrase_name =~ /^[^ \-][^ ]*-[^ ]*[^ \-]$/ )  <new_line>
                        {  <new_line>
                            $text_string = $list_of_source_words[ $pointer ] ;  <new_line>
                            $global_dashrep_replacement{ $target_phrase_name } = $text_string ;  <new_line>
                        }  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                        {  <new_line>
                            $global_trace_log .= "{{trace; warning, for action " . $action_name . " , the number of words in the source list " . $phrase_name_containing_source_words . " is less than the number of phrase names based on the parameter values in the list " . $phrase_name_containing_parameter_list . " so not all the copies were created" . "}}\n" ;  <new_line>
                        }  <new_line>
                        last ;  <new_line>
                    }  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                for ( $pointer = 0 ; $pointer <= $#list_of_parameter_words ; $pointer ++ )  <new_line>
                {  <new_line>
                    $source_phrase_name = $prefix . $list_of_parameter_words[ $pointer ] . $suffix ;  <new_line>
                    if ( ( $source_phrase_name =~ /^[^ ]+$/ ) && ( defined( $global_dashrep_replacement{ $source_phrase_name } ) ) )  <new_line>
                    {  <new_line>
                        $text_string = $global_dashrep_replacement{ $source_phrase_name } ;  <new_line>
                        $text_string =~ s/\n/ /sg ;  <new_line>
                        $text_string =~ s/^ +// ;  <new_line>
                        $text_string =~ s/ +$// ;  <new_line>
                        $global_dashrep_replacement{ $target_phrase_name } .= " " . $text_string ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; did action " . $action_name . " for phrases named " . $operand_one . " and " . $operand_two . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  copy-text  <new_line>
#  copy-to-phrase-from-following-text  <new_line>
#  put-into-phrase  <new_line>
#  copy-lowercase-only  <new_line>
#  copy-uppercase-only  <new_line>
#  copy-initial-caps  <new_line>
#  copy-without-extra-spaces  <new_line>
#  copy-words-sort-numeric  <new_line>
#  copy-words-sort-alphabetic  <new_line>
#  encode-as-cgi-parameter  <new_line>
#  decode-from-cgi-parameter  <new_line>

        if ( ( $action_name eq "copy-text" ) || ( $action_name eq "put-into-phrase" ) || ( $action_name eq "copy-to-phrase-from-following-text" ) || ( $action_name eq "copy-without-extra-spaces" ) || ( $action_name eq "copy-lowercase-only" ) || ( $action_name eq "copy-uppercase-only" ) || ( $action_name eq "copy-initial-caps" ) || ( $action_name eq "copy-words-sort-numeric" ) || ( $action_name eq "copy-words-sort-alphabetic" ) || ( $action_name eq "encode-as-cgi-parameter" ) || ( $action_name eq "decode-from-cgi-parameter" ) )  <new_line>
        {  <new_line>
            $source_phrase_name = $operand_one ;  <new_line>
            $target_phrase_name = $operand_two ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $source_phrase_name } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $source_phrase_name } = "" ;  <new_line>
            }  <new_line>
            $temp_text = $global_dashrep_replacement{ $source_phrase_name } ;  <new_line>
            if ( $action_name eq "copy-without-extra-spaces" )  <new_line>
            {  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/  +/ /g ;  <new_line>
                $temp_text =~ s/^ +// ;  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
            } elsif ( $action_name eq "copy-lowercase-only" )  <new_line>
            {  <new_line>
                $temp_text = lc( $temp_text ) ;  <new_line>
            } elsif ( $action_name eq "copy-uppercase-only" )  <new_line>
            {  <new_line>
                $temp_text = uc( $temp_text ) ;  <new_line>
            } elsif ( ( $action_name eq "copy-to-phrase-from-following-text" ) || ( $action_name eq "put-into-phrase" ) )  <new_line>
            {  <new_line>
                $temp_text = $operands_all ;  <new_line>
                $temp_text =~ s/^ *[^ ]+ +// ;  <new_line>
                $target_phrase_name = $operand_one ;  <new_line>
            } elsif ( $action_name eq "copy-initial-caps" )  <new_line>
            {  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/^ +// ;  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
                $remaining_text = $temp_text ;  <new_line>
                $accumulated_text = "" ;  <new_line>
                if ( $remaining_text =~ /^([a-z])(.*)$/ )  <new_line>
                {  <new_line>
                    $character_to_capitalize = $1 ;  <new_line>
                    $remaining_text = $2 ;  <new_line>
                    $accumulated_text .= uc( $character_to_capitalize ) ;  <new_line>
                }  <new_line>
                while ( $remaining_text =~ /^(.*?) ([a-z])(.*)$/ )  <new_line>
                {  <new_line>
                    $accumulated_text .= $1 ;  <new_line>
                    $character_to_capitalize = $2 ;  <new_line>
                    $remaining_text = $3 ;  <new_line>
                    $accumulated_text .= " " . uc( $character_to_capitalize ) ;  <new_line>
                }  <new_line>
                $accumulated_text .= $remaining_text ;  <new_line>
                $temp_text = $accumulated_text ;  <new_line>
            } elsif ( $action_name eq "encode-as-cgi-parameter" )  <new_line>
            {  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/ /\+/g ;  <new_line>
                $remaining_text = $temp_text ;  <new_line>
                $accumulated_text = "" ;  <new_line>
                while ( $remaining_text =~ /^(.*?)([^a-zA-Z0-9])(.*)$/s )  <new_line>
                {  <new_line>
                    $accumulated_text .= $1 ;  <new_line>
                    $character_to_replace = $2 ;  <new_line>
                    $remaining_text = $3 ;  <new_line>
                    $accumulated_text .= '%' . sprintf( "%02x" , ord( $character_to_replace ) ) ;  <new_line>
                }  <new_line>
                $accumulated_text .= $remaining_text ;  <new_line>
                $temp_text = $accumulated_text ;  <new_line>
            } elsif ( $action_name eq "decode-from-cgi-parameter" )  <new_line>
            {  <new_line>
                $temp_text =~ s/\+/ /sg ;  <new_line>
                $remaining_text = $temp_text ;  <new_line>
                $accumulated_text = "" ;  <new_line>

# Edited 2017-june-1  <new_line>
                while ( $remaining_text =~ /^(.*?)(\%[0-9a-fA-F][0-9a-fA-F])(.*)$/s )  <new_line>
#                while ( $remaining_text =~ /^(.*?)(\%[0-9][0-9])(.*)$/s )  <new_line>

                {  <new_line>
                    $accumulated_text .= $1 ;  <new_line>
                    $character_code_to_decode = $2 ;  <new_line>
                    $remaining_text = $3 ;  <new_line>
                    $accumulated_text .= chr( hex( $character_code_to_decode ) ) ;  <new_line>
                }  <new_line>
                $accumulated_text .= $remaining_text ;  <new_line>
                $temp_text = $accumulated_text ;  <new_line>
            } elsif ( $action_name eq "copy-words-sort-numeric" )  <new_line>
            {  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/^ +// ;  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
                @list = split( / +/ , $temp_text ) ;  <new_line>
                @list_of_sorted_numbers = sort { $a <=> $b } @list ;  <new_line>
                $temp_text = join( " " , @list_of_sorted_numbers ) ;  <new_line>
            } elsif ( $action_name eq "copy-words-sort-alphabetic" )  <new_line>
            {  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/^ +// ;  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
                @list = split( / +/ , $temp_text ) ;  <new_line>
                @list_of_sorted_numbers = sort( @list ) ;  <new_line>
                $temp_text = join( " " , @list_of_sorted_numbers ) ;  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $target_phrase_name } = $temp_text ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from phrase " . $source_phrase_name . " to phrase " . $target_phrase_name . " with any specified changes}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  convert-unicode-to-html-entities  <new_line>
#  <new_line>
#  Converts non-ASCII characters, and convert a few  <new_line>
#  ASCII characters such as:  <new_line>
#  11 which is "LF" (line feed)  <new_line>
#  13 which is "CR" (carriage return)  <new_line>
#  127 which is "del"  <new_line>

        if ( $action_name eq "convert-unicode-to-html-entities" )  <new_line>
        {  <new_line>
            $source_phrase_name = $operand_one ;  <new_line>
            $target_phrase_name = $operand_two ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $source_phrase_name } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $source_phrase_name } = "" ;  <new_line>
            }  <new_line>
            $accumulated_text = "" ;  <new_line>
            @octet_number_at_position = unpack( "C*" , $global_dashrep_replacement{ $source_phrase_name } ) ;  <new_line>
            $yes_or_no_within_ampersand_encoded_character = "no" ;  <new_line>
            $pointer = -1 ;  <new_line>
            while ( $pointer < $#octet_number_at_position )  <new_line>
            {  <new_line>
                $pointer ++ ;  <new_line>
                $octet_number = $octet_number_at_position[ $pointer ] ;  <new_line>
                if ( $octet_number < 32 )  <new_line>
                {  <new_line>
                    $unicode_number = $octet_number ;  <new_line>
                    $accumulated_text .= '&#' . $unicode_number . ';' ;  <new_line>
                } elsif ( $octet_number < 127 )  <new_line>
                {  <new_line>
                    $accumulated_text .= chr( $octet_number ) ;  <new_line>
                } elsif ( $octet_number >= 0xfc )  <new_line>
                {  <new_line>
                    $unicode_number = ( ( ( ( ( ( ( ( ( ( $octet_number - 0xfc ) * 64 ) + $octet_number_at_position[ $pointer + 1 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 2 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 3 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 4 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 5 ] - 128 ;  <new_line>
                    $accumulated_text .= '&#' . $unicode_number . ';' ;  <new_line>
                    $pointer += 5 ;  <new_line>
                } elsif ( $octet_number >= 0xf8 )  <new_line>
                {  <new_line>
                    $unicode_number = ( ( ( ( ( ( ( ( $octet_number - 0xf8 ) * 64 ) + $octet_number_at_position[ $pointer + 1 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 2 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 3 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 4 ] - 128 ;  <new_line>
                    $accumulated_text .= '&#' . $unicode_number . ';' ;  <new_line>
                    $pointer += 4 ;  <new_line>
                } elsif ( $octet_number >= 0xf0 )  <new_line>
                {  <new_line>
                    $unicode_number = ( ( ( ( ( ( $octet_number - 0xf0 ) * 64 ) + $octet_number_at_position[ $pointer + 1 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 2 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 3 ] - 128 ;  <new_line>
                    $accumulated_text .= '&#' . $unicode_number . ';' ;  <new_line>
                    $pointer += 3 ;  <new_line>
                } elsif ( $octet_number >= 0xe0 )  <new_line>
                {  <new_line>
                    $unicode_number = ( ( ( ( $octet_number - 0xe0 ) * 64 ) + $octet_number_at_position[ $pointer + 1 ] - 128 ) * 64 ) + $octet_number_at_position[ $pointer + 2 ] - 128 ;  <new_line>
                    $accumulated_text .= '&#' . $unicode_number . ';' ;  <new_line>
                    $pointer += 2 ;  <new_line>
                } elsif ( $octet_number >= 0xc0 )  <new_line>
                {  <new_line>
                    $unicode_number = ( ( $octet_number - 0xc0 ) * 64 ) + $octet_number_at_position[ $pointer + 1 ] - 128 ;  <new_line>
                    $accumulated_text .= '&#' . $unicode_number . ';' ;  <new_line>
                    $pointer += 1 ;  <new_line>
                } elsif ( $octet_number > 0 )  <new_line>
                {  <new_line>
                    $unicode_number = $octet_number ;  <new_line>
                    $accumulated_text .= '&#' . $unicode_number . ';' ;  <new_line>
                }  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $target_phrase_name } = $accumulated_text ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from phrase " . $source_phrase_name . " to phrase " . $target_phrase_name . " with unicode translation}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  convert-into-spoken-dashrep-code  <new_line>
#  convert-from-spoken-dashrep-code  <new_line>

        if ( ( $action_name eq "convert-into-spoken-dashrep-code" ) || ( $action_name eq "convert-from-spoken-dashrep-code" ) )  <new_line>
        {  <new_line>
            $source_phrase_name = $operand_one ;  <new_line>
            $target_phrase_name = $operand_two ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $source_phrase_name } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $source_phrase_name } = "" ;  <new_line>
            }  <new_line>
            $temp_text = $global_dashrep_replacement{ $source_phrase_name } ;  <new_line>
            if ( $action_name eq "convert-into-spoken-dashrep-code" )  <new_line>
            {  <new_line>
                $temp_text =~ s/^ +//sg ;  <new_line>
                $temp_text =~ s/ +$//sg ;  <new_line>
                $temp_text = " " . $temp_text . " " ;  <new_line>
                $temp_text =~ s/\t+/ /sg ;  <new_line>
                $temp_text =~ s/  +/ /sg ;  <new_line>
                $temp_text =~ s/[\n\r]/ linbray /sg ;  <new_line>
                $temp_text =~ s/-\[-/ fenambee /sg ;  <new_line>
                $temp_text =~ s/-\]-/ amennfen /sg ;  <new_line>
                $temp_text =~ s/\[-/ ambee /sg ;  <new_line>
                $temp_text =~ s/-\]/ amenn /sg ;  <new_line>
                $temp_text =~ s/ ([^ ]+(-[^ ]+)+) / dashbee $1 dashenn /sg ;  <new_line>
                $temp_text =~ s/-/ fen /sg ;  <new_line>
                $temp_text =~ s/^ +//sg ;  <new_line>
                $temp_text =~ s/ +$//sg ;  <new_line>
                $temp_text =~ s/  +/ /sg ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $temp_text =~ s/\t+/ /sg ;  <new_line>
                $temp_text = " " . $temp_text . " " ;  <new_line>
                $temp_text =~ s/  +/ /sg ;  <new_line>
                $temp_text =~ s/ dashnex / dashenn dashbee /sg ;  <new_line>
                $temp_text =~ s/ wunspay / one-space /sg ;  <new_line>
                $temp_text =~ s/ feneer / hyphen-here /sg ;  <new_line>
                $temp_text =~ s/ senek / sentence-next /sg ;  <new_line>
                while ( $temp_text =~ /^(.* )ofo ([^ \]]+?) ofo( .*)$/s )  <new_line>
                {  <new_line>
                    $prefix = $1 ;  <new_line>
                    $phrase_words = $2 ;  <new_line>
                    $suffix = $3 ;  <new_line>
                    $temp_text = $prefix . " dashbee " . $phrase_words . " dashenn " . $suffix ;  <new_line>
                }  <new_line>
                while ( $temp_text =~ /^(.* )ofo ([^ \]]+?)-\]( .*)$/s )  <new_line>
                {  <new_line>
                    $prefix = $1 ;  <new_line>
                    $phrase_words = $2 ;  <new_line>
                    $suffix = $3 ;  <new_line>
                    $temp_text = $prefix . " dashbee " . $phrase_words . " dashenn " . $suffix ;  <new_line>
                }  <new_line>
                while ( $temp_text =~ /^(.* )dashbee (.+?) dashenn( .*)$/s )  <new_line>
                {  <new_line>
                    $prefix = $1 ;  <new_line>
                    $phrase_words = $2 ;  <new_line>
                    $suffix = $3 ;  <new_line>
                    $phrase_words =~ s/ +/-/sg ;  <new_line>
                    $temp_text = $prefix . $phrase_words . $suffix ;  <new_line>
                }  <new_line>
                while ( $temp_text =~ / ((ambee)|(amenn)|(fen)|(combee)|(comenn)|(newline)(fenambee)|(amennfen)) /s )  <new_line>
                {  <new_line>
                    $temp_text =~ s/ ambee / \[-/sg ;  <new_line>
                    $temp_text =~ s/ amenn /-\] /sg ;  <new_line>
                    $temp_text =~ s/ fen / - /sg ;  <new_line>
                    $temp_text =~ s/([^a-z0-9])fen-/$1-/sg ;  <new_line>
                    $temp_text =~ s/-fen([^a-z0-9])/-$1/sg ;  <new_line>
                    $temp_text =~ s/ combee / *---- /sg ;  <new_line>
                    $temp_text =~ s/ comenn / ----* /sg ;  <new_line>
                    $temp_text =~ s/ fenambee /-\[-/sg ;  <new_line>
                    $temp_text =~ s/ amennfen /-\]-/sg ;  <new_line>
                    $temp_text =~ s/ newline / linbray /sg ;  <new_line>
                }  <new_line>
                $temp_text =~ s/\[- /\[-/sg ;  <new_line>
                $temp_text =~ s/ -\]/-\]/sg ;  <new_line>
                $temp_text =~ s/ -/-/sg ;  <new_line>
                $temp_text =~ s/- /-/sg ;  <new_line>
                while ( $temp_text =~ / linbray /s )  <new_line>
                {  <new_line>
                    $temp_text =~ s/ linbray / \n /sg ;  <new_line>
                }  <new_line>
                $temp_text =~ s/ \n/\n/sg ;  <new_line>
                $temp_text =~ s/\n /\n/sg ;  <new_line>
                $temp_text =~ s/^ +//sg ;  <new_line>
                $temp_text =~ s/ +$//sg ;  <new_line>
                $temp_text =~ s/  +/ /sg ;  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $target_phrase_name } = $temp_text ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from phrase " . $source_phrase_name . " to phrase " . $target_phrase_name . " with translation}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  xml-move-attributes-into-tag-elements  <new_line>

        if ( $action_name eq "xml-move-attributes-into-tag-elements" )  <new_line>
        {  <new_line>
            $phrase_being_edited = $operand_one ;  <new_line>
            $text_being_edited = $global_dashrep_replacement{ $phrase_being_edited } ;  <new_line>
            while( $text_being_edited =~ / *\/> *<((attribute)|(specify)) ([^>]+)>/sg )  <new_line>
            {  <new_line>
                $text_being_edited =~ s/ *\/> *<((attribute)|(specify)) (([^"<>]*"[^"]*"[^"<>]*)+?)>/ $4 \/>/sg ;  <new_line>
                $global_replacement_count_for_item_name{ "loop within action " . $action_name } ++ ;  <new_line>
                if ( $global_endless_loop_counter > $global_endless_loop_counter_limit - 100 )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; Error: During the action " . $action_name . " the endless loop counter got within 100 counts of exceeding its limit, so no more replacements will be done by this action.}}\n";  <new_line>
                    last ;  <new_line>
                }  <new_line>
                $global_endless_loop_counter ++ ;  <new_line>
            }  <new_line>
            while( $text_being_edited =~ / *> *<((attribute)|(specify)) ([^>]+)>/sg )  <new_line>
            {  <new_line>
                $text_being_edited =~ s/ *> *<((attribute)|(specify)) (([^"<>]*"[^"]*"[^"<>]*)+?)>/ $4>/sg ;  <new_line>
                $global_replacement_count_for_item_name{ "loop within action " . $action_name } ++ ;  <new_line>
                if ( $global_endless_loop_counter > $global_endless_loop_counter_limit - 100 )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; Error: During the action " . $action_name . " the endless loop counter got within 100 counts of exceeding its limit, so no more replacements will be done by this action.}}\n";  <new_line>
                    last ;  <new_line>
                }  <new_line>
                $global_endless_loop_counter ++ ;  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $phrase_being_edited } = $text_being_edited ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; within phrase " . $phrase_being_edited . " moved attributes into tag elements}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  copy-and-remove-attributes-from-xml-tags  <new_line>

        if ( $action_name eq "copy-and-remove-attributes-from-xml-tags" )  <new_line>
        {  <new_line>
            $text_being_edited = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            $text_being_edited =~ s/< *(\/?) *([a-zA-Z]+)[^>\/]*(\/?)[^>]*>/<$1$2$3>/gi ;  <new_line>
            $text_being_edited =~ s/><!\[CDATA\[/>/gi ;  <new_line>
            $text_being_edited =~ s/\]\]></</gi ;  <new_line>
            $global_dashrep_replacement{ $operand_two } = $text_being_edited ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; within phrase " . $phrase_being_edited . " removed attributes from tags}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  insert-angle-bracketed-definitions  <new_line>

        if ( $action_name eq "insert-angle-bracketed-definitions" )  <new_line>
        {  <new_line>
            $phrase_being_edited = $operand_one ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $phrase_being_edited } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $phrase_being_edited } = "" ;  <new_line>
            }  <new_line>
            $remaining_text = $global_dashrep_replacement{ $phrase_being_edited } ;  <new_line>
            $accumulated_text = "" ;  <new_line>
            $remaining_text =~ s/<character_open_angle_bracket>character_hyphen<character_close_angle_bracket>/-/sg ;  <new_line>
            while ( $remaining_text =~ /^(.*?)<([^ _<>;:=,\-]+_[^ <>;:=,\-]+)>(.*)$/s )  <new_line>
            {  <new_line>
                $accumulated_text .= $1 ;  <new_line>
                $possible_phrase_name = $2 ;  <new_line>
                $remaining_text = $3 ;  <new_line>
                $phrase_name = $possible_phrase_name ;  <new_line>
                $phrase_name =~ s/_/-/g ;  <new_line>
                if ( exists( $global_dashrep_replacement{ $phrase_name } ) )  <new_line>
                {  <new_line>
                    $accumulated_text .= $global_dashrep_replacement{ $phrase_name } ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $accumulated_text .= "<" . $possible_phrase_name . ">" ;  <new_line>
                }  <new_line>
                $global_endless_loop_counter ++ ;  <new_line>
                $global_replacement_count_for_item_name{ "loop within action " . $action_name } ++ ;  <new_line>
                if ( $global_endless_loop_counter > $global_endless_loop_counter_limit - 100 )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; Error: During the action " . $action_name . " the endless loop counter got within 100 counts of exceeding its limit, so no more replacements will be done by this action.}}\n";  <new_line>
                    $accumulated_text .= $remaining_text ;  <new_line>
                    $remaining_text = "" ;  <new_line>
                    last ;  <new_line>
                }  <new_line>
            }  <new_line>
            $accumulated_text .= $remaining_text ;  <new_line>
            $accumulated_text =~ s/ *<no_space> *//sg ;  <new_line>
            $accumulated_text =~ s/ *<new_line> */\n/sg ;  <new_line>
            $global_dashrep_replacement{ $phrase_being_edited } = $accumulated_text ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; within phrase " . $phrase_being_edited . " replaced translation-safe phrases with their definitions}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  copy-word-at-position  <new_line>
#  copy-words-rearrange-using-order-sort-alphabetic  <new_line>
#  copy-words-rearrange-using-order-sort-numeric  <new_line>

        if ( ( $action_name eq "copy-word-at-position" ) || ( $action_name eq "copy-words-rearrange-using-order-sort-alphabetic" ) || ( $action_name eq "copy-words-rearrange-using-order-sort-numeric" ) )  <new_line>
        {  <new_line>
            if ( ( $action_name eq "copy-words-rearrange-using-order-sort-numeric" ) && ( $global_dashrep_replacement{ $operand_three } =~ /[^0-9\.\- ]/ ) )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , operand " . $operand_three . " contains non-numeric content: " . $global_dashrep_replacement{ $operand_three } . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            $source_phrase_name = $operand_one ;  <new_line>
            $target_phrase_name = $operand_two ;  <new_line>
# previously, next line removed instead of replaced:  <new_line>
            $source_phrase_name =~ s/\n/ /g ;  <new_line>
            if ( ( $source_phrase_name !~ /^[^ ]+$/ ) || ( not( exists( $global_dashrep_replacement{ $source_phrase_name } ) ) ) || ( not( defined( $global_dashrep_replacement{ $source_phrase_name } ) ) ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; copied nothing because phrase " . $operand_one . " is not defined}}\n" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $source_text = $global_dashrep_replacement{ $source_phrase_name } ;  <new_line>
                $source_text =~ s/\n/ /sg ;  <new_line>
                $source_text =~ s/^ +// ;  <new_line>
                $source_text =~ s/ +$// ;  <new_line>
                if ( $action_name eq "copy-word-at-position" )  <new_line>
                {  <new_line>
                    if ( $operand_three =~ /^[0-9]+$/ )  <new_line>
                    {  <new_line>
                        $word_position = $operand_three + 0 ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        $word_position = 1 ;  <new_line>
                    }  <new_line>
                    if ( $source_text =~ / / )  <new_line>
                    {  <new_line>
                        @list_of_words = split( / +/ , $source_text ) ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        @list_of_words = ( ) ;  <new_line>
                        $list_of_words[ 0 ] = $source_text ;  <new_line>
                    }  <new_line>
                    if ( $word_position > scalar( @list_of_words + 1 ) )  <new_line>
                    {  <new_line>
                        $word_position = scalar( @list_of_words + 1 ) ;  <new_line>
                    }  <new_line>
                    $global_dashrep_replacement{ $target_phrase_name } = $list_of_words[ $word_position - 1 ] ;  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; copied word number " . $word_position . " from phrase " . $source_phrase_name . " to phrase " . $target_phrase_name . "}}\n" ;  <new_line>
                    }  <new_line>
                } elsif ( ( $action_name eq "copy-words-rearrange-using-order-sort-alphabetic" ) || ( $action_name eq "copy-words-rearrange-using-order-sort-numeric" ) )  <new_line>
                {  <new_line>
                    if ( $source_text =~ / / )  <new_line>
                    {  <new_line>
                        @list_of_words = split( / +/ , $source_text ) ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        @list_of_words = ( ) ;  <new_line>
                        $list_of_words[ 0 ] = $source_text ;  <new_line>
                    }  <new_line>
                    $list_indicating_sort_order_text_string = $global_dashrep_replacement{ $operand_three } ;  <new_line>
                    $list_indicating_sort_order_text_string =~ s/\n/ /s ;  <new_line>
                    $list_indicating_sort_order_text_string =~ s/^ +// ;  <new_line>
                    $list_indicating_sort_order_text_string =~ s/ +$// ;  <new_line>
                    @list_indicating_sort_order = split( / +/ , $list_indicating_sort_order_text_string ) ;  <new_line>

                    if ( $action_name eq "copy-words-rearrange-using-order-sort-numeric" )  <new_line>
                    {  <new_line>
                        @sort_order = sort { $a <=> $b } @list_indicating_sort_order ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        @sort_order = sort( @list_indicating_sort_order ) ;  <new_line>
                    }  <new_line>
                    $extra_words_without_sort_value = "" ;  <new_line>
                    if ( $#list_indicating_sort_order < $#list_of_words )  <new_line>
                    {  <new_line>
                        for ( $word_position = ( $#list_indicating_sort_order + 2 ) ; $word_position <= ( $#list_of_words + 1 ) ; $word_position ++ )  <new_line>
                        {  <new_line>
                            $extra_words_without_sort_value .= $list_of_words[ $word_position - 1 ] . " " ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                    %words_at_numeric_value = ( ) ;  <new_line>
                    for ( $word_position = 1 ; $word_position <= ( $#list_indicating_sort_order + 1 ) ; $word_position ++ )  <new_line>
                    {  <new_line>
                        $numeric_value = $list_indicating_sort_order[ $word_position - 1 ] ;  <new_line>
                        $words_at_numeric_value{ $numeric_value } .= $list_of_words[ $word_position - 1 ] . " " ;  <new_line>
                    }  <new_line>
                    $text_string = "" ;  <new_line>
                    foreach $numeric_value ( @sort_order )  <new_line>
                    {  <new_line>
                        if ( $words_at_numeric_value{ $numeric_value } =~ /[^ ]/ )  <new_line>
                        {  <new_line>
                            $text_string .= $words_at_numeric_value{ $numeric_value } . " " ;  <new_line>
                            $words_at_numeric_value{ $numeric_value } = "" ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                    $text_string .= " " . $extra_words_without_sort_value ;  <new_line>
                    $text_string =~ s/ +/ /g ;  <new_line>
                    $text_string =~ s/ $// ;  <new_line>
                    $global_dashrep_replacement{ $target_phrase_name } = $text_string ;  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; copied words from phrase " . $source_phrase_name . " to phrase " . $target_phrase_name . " in order specified numeric content in phrase " . $operand_three . "}}\n" ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  copy-zero-pad-left-to-length  <new_line>

        if ( $action_name eq "copy-zero-pad-left-to-length" )  <new_line>
        {  <new_line>
            $source_phrase_name = $operand_one ;  <new_line>
            $target_phrase_name = $operand_two ;  <new_line>
            if ( ( $source_phrase_name !~ /^[^ ]+$/ ) || ( not( exists( $global_dashrep_replacement{ $source_phrase_name } ) ) ) || ( not( defined( $global_dashrep_replacement{ $source_phrase_name } ) ) ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; copied nothing because phrase " . $operand_one . " is not defined}}\n" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $source_text = $global_dashrep_replacement{ $source_phrase_name } ;  <new_line>
                $source_text =~ s/^ +// ;  <new_line>
                $source_text =~ s/ +$// ;  <new_line>
                $length_desired = $operand_three + 0 ;  <new_line>
                $number_of_zeros_needed = $length_desired - length( $source_text ) ;  <new_line>
                $zero_padding = "" ;  <new_line>
                while ( ( $number_of_zeros_needed > 0 ) && ( $number_of_zeros_needed < 99 ) )  <new_line>
                {  <new_line>
                    $zero_padding .= "0" ;  <new_line>
                    $number_of_zeros_needed -- ;  <new_line>
                }  <new_line>
                $global_dashrep_replacement{ $target_phrase_name } = $zero_padding . $source_text ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; copied word from phrase " . $source_phrase_name . " to phrase " . $target_phrase_name . " and padded it with zeros" . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  copy-characters-from-position-to-position  <new_line>

        if ( $action_name eq "copy-characters-from-position-to-position" )  <new_line>
        {  <new_line>
            $source_phrase_name = $operand_one ;  <new_line>
            $target_phrase_name = $operand_two ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $source_phrase_name } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $source_phrase_name } = "" ;  <new_line>
            }  <new_line>
            $pointer_one = -1 ;  <new_line>
            $pointer_two = -1 ;  <new_line>
            if ( $operand_three =~ /^([0-9]+)$/ )  <new_line>
            {  <new_line>
                $pointer_one = $1 ;  <new_line>
            }  <new_line>
            if ( $operand_four =~ /^([0-9]+)$/ )  <new_line>
            {  <new_line>
                $pointer_two = $1 ;  <new_line>
            }  <new_line>
            if ( ( $pointer_one == -1 ) || ( $pointer_two == -1 ) || ( $pointer_one > $pointer_two ) )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , operand " . $operand_three . " or operand " . $operand_four . " is not a positive integer number, or the first number is larger than the second number (context: operand one is " . $operand_one . " and operand two is " . $operand_two . ")" . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            $source_text = $global_dashrep_replacement{ $source_phrase_name } ;  <new_line>
            $global_dashrep_replacement{ $target_phrase_name } = substr( $source_text , ( $pointer_one - 1 ) , ( $pointer_two - $pointer_one + 1 ) ) ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied some characters from phrase " . $source_phrase_name . " to phrase " . $target_phrase_name . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  copy-and-replace  <new_line>

        if ( $action_name eq "copy-and-replace" )  <new_line>
        {  <new_line>
            $source_phrase_name = $operand_one ;  <new_line>
            $target_phrase_name = $operand_two ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $source_phrase_name } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $source_phrase_name } = "" ;  <new_line>
            }  <new_line>
            $string_to_be_replaced = $global_dashrep_replacement{ $operand_three } ;  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_four } ) )  <new_line>
            {  <new_line>
                $text_to_insert = $global_dashrep_replacement{ $operand_four } ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $text_to_insert = "" ;  <new_line>
            }  <new_line>
            $source_text = $global_dashrep_replacement{ $source_phrase_name } ;  <new_line>
            if ( ( length( $text_to_insert ) >= length( $string_to_be_replaced ) ) && ( index( $text_to_insert , $string_to_be_replaced ) >= 0 ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning: replacement string (" . $text_to_insert . ") contains string to replace (" . $string_to_be_replaced . "), so no replacements done}}\n" ;  <new_line>
                }  <new_line>
            } elsif ( ( length( $string_to_be_replaced ) >= length( $text_to_insert ) ) && ( length( $text_to_insert ) > 0 ) && ( index( $string_to_be_replaced , $text_to_insert ) >= 0 ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning: string to replace (" . $string_to_be_replaced . ") contains replacement string (" . $text_to_insert . "), so no replacements done}}\n" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $length_of_string_to_be_replaced = length( $string_to_be_replaced ) ;  <new_line>
                $character_position = index( $source_text , $string_to_be_replaced ) ;  <new_line>
                while ( $character_position >= 0 )  <new_line>
                {  <new_line>
                    $source_text = substr( $source_text , 0 , $character_position ) . $text_to_insert . substr( $source_text , $character_position + $length_of_string_to_be_replaced ) ;  <new_line>
                    $character_position = index( $source_text , $string_to_be_replaced ) ;  <new_line>
                    $global_endless_loop_counter ++ ;  <new_line>
                    $global_replacement_count_for_item_name{ "loop within action " . $action_name } ++ ;  <new_line>
                    if ( $global_endless_loop_counter > $global_endless_loop_counter_limit - 100 )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; Error: During the action " . $action_name . " the endless loop counter got within 100 counts of exceeding its limit, so no more replacements will be done by this action.}}\n";  <new_line>
                        last ;  <new_line>
                    }  <new_line>
                }  <new_line>
                $global_dashrep_replacement{ $target_phrase_name } = $source_text ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; copied from phrase " . $source_phrase_name . " to phrase " . $target_phrase_name . " with replacements}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  copy-and-replace-using-paired-listed-words  <new_line>

        if ( $action_name eq "copy-and-replace-using-paired-listed-words" )  <new_line>
        {  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $operand_one } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $operand_one } = "" ;  <new_line>
            }  <new_line>
            $result_text = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $operand_three } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $operand_three } = "" ;  <new_line>
            }  <new_line>
            $paired_words_as_text = $global_dashrep_replacement{ $operand_three } ;  <new_line>
            $paired_words_as_text =~ s/\n/ /sg ;  <new_line>
            $paired_words_as_text =~ s/^ +// ;  <new_line>
            $paired_words_as_text =~ s/ +$// ;  <new_line>
            @list_of_paired_words = split( / +/ , $paired_words_as_text ) ;  <new_line>
            $pair_status = "search" ;  <new_line>
            for ( $pair_pointer_offset_zero = 0 ; $pair_pointer_offset_zero <= $#list_of_paired_words ; $pair_pointer_offset_zero ++ )  <new_line>
            {  <new_line>
                if ( $pair_status eq "search" )  <new_line>
                {  <new_line>
                    $string_to_be_replaced = $list_of_paired_words[ $pair_pointer_offset_zero ] ;  <new_line>
                    $pair_status = "replace" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $string_to_insert = $list_of_paired_words[ $pair_pointer_offset_zero ] ;  <new_line>
                    $remaining_text = $result_text ;  <new_line>
                    $result_text = "" ;  <new_line>
                    $pointer_to_matching_text = index( $remaining_text , $string_to_be_replaced ) ;  <new_line>
                    while ( $pointer_to_matching_text >= 0 )  <new_line>
                    {  <new_line>
                        if ( $pointer_to_matching_text > 0 )  <new_line>
                        {  <new_line>
                            $result_text .= substr( $remaining_text , 0 , $pointer_to_matching_text ) ;  <new_line>
                        }  <new_line>
                        $result_text .= $string_to_insert ;  <new_line>
                        $remaining_text = substr( $remaining_text , ( $pointer_to_matching_text + length( $string_to_be_replaced ) ) ) ;  <new_line>
                        $pointer_to_matching_text = index( $remaining_text , $string_to_be_replaced ) ;  <new_line>
                    }  <new_line>
                    $result_text .= $remaining_text ;  <new_line>
                    $pair_status = "search" ;  <new_line>
                }  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $operand_two } = $result_text ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; copied from phrase " . $operand_one . " to phrase " . $operand_two . " with replacements specified in phrase " . $operand_three . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  expand-text  <new_line>
#  expand-parameters-only  <new_line>

        if ( $action_name eq "expand-text" )  <new_line>
#        if ( ( $action_name eq "expand-text" ) || ( $action_name eq "expand-parameters-only" ) )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $text_to_expand = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                $global_recursion_level_of_expand_parameters ++ ;  <new_line>
                $partial_translation = &dashrep_expand_parameters( $text_to_expand ) ;  <new_line>
                $global_recursion_level_of_expand_parameters -- ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-debug-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; after parameters expanded: " . $partial_translation . "}}\n" ;  <new_line>
                }  <new_line>
                if ( $action_name ne "expand-parameters-only" )  <new_line>
                {  <new_line>
                    $translation = &dashrep_expand_phrases( $partial_translation );  <new_line>
                } else  <new_line>
                {  <new_line>
                    $translation = $partial_translation ;  <new_line>
                }  <new_line>

#  causes bug in some Dashrep code, so this update not yet implemented:  <new_line>
#                $translation =~ s/^ +// ;  <new_line>
#                $translation =~ s/ +$// ;  <new_line>

                $global_dashrep_replacement{ $operand_two } = $translation ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; expanded phrase " . $operand_one . " into phrase " . $operand_two . "}}\n" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $operand_two } = "" ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, cannot expand undefined phrase " . $operand_one . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  get-phrase-definition-without-expanding  <new_line>

        if ( $action_name eq "get-phrase-definition-without-expanding" )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $action_result = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; inserted definition of phrase " . $operand_one . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  numeric-equal-greater-less-compare  <new_line>

        if ( $action_name eq "numeric-equal-greater-less-compare" )  <new_line>
        {  <new_line>
            $first_object_of_action = $operand_one + 0 ;  <new_line>
            $second_object_of_action = $operand_two + 0 ;  <new_line>
            if ( $first_object_of_action == $second_object_of_action )  <new_line>
            {  <new_line>
                $action_result = "equal" ;  <new_line>
            } elsif ( $first_object_of_action > $second_object_of_action )  <new_line>
            {  <new_line>
                $action_result = "greater" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $action_result = "less" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  yes-if-not-no  <new_line>
#  no-if-any-no  <new_line>

        if ( ( $action_name eq "yes-if-not-no" ) || ( $action_name eq "no-if-any-no" ) )  <new_line>
        {  <new_line>
            if ( $operands_all =~ /no/i )  <new_line>
            {  <new_line>
                $yes_or_no = "no" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $yes_or_no = "yes" ;  <new_line>
            }  <new_line>
            $replacement_text = $text_begin . $yes_or_no . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  no-if-not-yes  <new_line>
#  yes-if-any-yes  <new_line>

        if ( ( $action_name eq "no-if-not-yes" ) || ( $action_name eq "yes-if-any-yes" ) )  <new_line>
        {  <new_line>
            if ( $operands_all =~ /yes/i )  <new_line>
            {  <new_line>
                $yes_or_no = "yes" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $yes_or_no = "no" ;  <new_line>
            }  <new_line>
            $replacement_text = $text_begin . $yes_or_no . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  yes-if-all-yes  <new_line>

        if ( $action_name eq "yes-if-all-yes" )  <new_line>
        {  <new_line>
            if ( $operands_all =~ / *(yes *)+/i )  <new_line>
            {  <new_line>
                $yes_or_no = "yes" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $yes_or_no = "no" ;  <new_line>
            }  <new_line>
            $replacement_text = $text_begin . $yes_or_no . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  yes-or-no-opposite  <new_line>

        if ( $action_name eq "yes-or-no-opposite" )  <new_line>
        {  <new_line>
            if ( $operands_all =~ /yes/i )  <new_line>
            {  <new_line>
                $yes_or_no = "no" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $yes_or_no = "yes" ;  <new_line>
            }  <new_line>
            $replacement_text = $text_begin . $yes_or_no . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  get-word-at-position  <new_line>

        if ( $action_name eq "get-word-at-position" )  <new_line>
        {  <new_line>
            $word_number = $operand_two + 0 ;  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $temp_text = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/^ +// ;  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
                @list = split( / +/ , $temp_text ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                @list = ( ) ;  <new_line>
            }  <new_line>
            $count = $#list + 1 ;  <new_line>
            if ( $count >= 1 )  <new_line>
            {  <new_line>
                if ( $word_number > $count )  <new_line>
                {  <new_line>
                    $word_number = $count ;  <new_line>
                }  <new_line>
                $action_result = $list[ $word_number - 1 ] ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  copy-words-from-position-to-position  <new_line>

        if ( $action_name eq "copy-words-from-position-to-position" )  <new_line>
        {  <new_line>
            $word_number_begin = $operand_three + 0 ;  <new_line>
            $word_number_end = $operand_four + 0 ;  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $temp_text = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/^ +// ;  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
                @list = split( / +/ , $temp_text ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                @list = ( ) ;  <new_line>
            }  <new_line>
            $word_count = $#list + 1 ;  <new_line>
            if ( $word_number_end > $word_count )  <new_line>
            {  <new_line>
                $word_number_end = $word_count ;  <new_line>
            }  <new_line>
            if ( ( $word_count < 1 ) || ( $word_number_begin < 1 ) || ( $word_number_end < 1 ) || ( $word_number_begin > $word_count ) || ( $word_number_end < $word_number_begin ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $operand_two } = "" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $result_text = "" ;  <new_line>
                $separator = "" ;  <new_line>
                $global_dashrep_replacement{ $operand_two } = "" ;  <new_line>
                for ( $word_number = $word_number_begin ; $word_number <= $word_number_end ; $word_number ++ )  <new_line>
                {  <new_line>
                    $result_text .= $separator . $list[ $word_number - 1 ] ;  <new_line>
                    $separator = " " ;  <new_line>
                }  <new_line>
                $result_text =~ s/ +$// ;  <new_line>
                $global_dashrep_replacement{ $operand_two } = $result_text ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  copy-words-order-reversed  <new_line>
#  (useful for inserting commas or decimal points into integers)  <new_line>

        if ( $action_name eq "copy-words-order-reversed" )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $temp_text = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/^ +// ;  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
                @list = split( / +/ , $temp_text ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                @list = ( ) ;  <new_line>
            }  <new_line>
            $count = $#list + 1 ;  <new_line>
            $temp_text = "" ;  <new_line>
            if ( $count > 0 )  <new_line>
            {  <new_line>
                for ( $word_number = $count ; $word_number >= 1 ; $word_number -- )  <new_line>
                {  <new_line>
                    $temp_text .= $list[ $word_number - 1 ] . " " ;  <new_line>
                }  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $operand_two } = $temp_text ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  get-count-of-words  <new_line>

        if ( $action_name eq "get-count-of-words" )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $temp_text = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                $temp_text =~ s/\n/ /sg ;  <new_line>
                $temp_text =~ s/^ +// ;  <new_line>
                $temp_text =~ s/ +$// ;  <new_line>
                @list = split( / +/ , $temp_text ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                @list = ( ) ;  <new_line>
            }  <new_line>
            $count = $#list + 1 ;  <new_line>
            if ( $count > 0 )  <new_line>
            {  <new_line>
                $action_result = $count ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $action_result = "0" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  yes-or-no-word-is-in-phrase  <new_line>
#  get-position-of-word  <new_line>

        if ( ( $action_name eq "yes-or-no-word-is-in-phrase" ) || ( $action_name eq "get-position-of-word" ) )  <new_line>
        {  <new_line>
            if ( $action_name eq "get-position-of-word" )  <new_line>
            {  <new_line>
                $word_to_find = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $word_to_find = $operand_one ;  <new_line>
            }  <new_line>
            $phrase_name = $operand_two ;  <new_line>
            $temp_text = $global_dashrep_replacement{ $phrase_name } ;  <new_line>
            $temp_text =~ s/\n/ /sg ;  <new_line>
            $temp_text =~ s/^ +// ;  <new_line>
            $temp_text =~ s/ +$// ;  <new_line>
            @list = split( / +/ , $temp_text ) ;  <new_line>
            $list_length = $#list + 1 ;  <new_line>
            if ( $action_name eq "get-position-of-word" )  <new_line>
            {  <new_line>
                $action_result = "0" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $action_result = "no" ;  <new_line>
            }  <new_line>
            if ( $list_length >= 1 )  <new_line>
            {  <new_line>
                $last_pointer = 0 ;  <new_line>
                for ( $pointer = 1 ; $pointer <= $list_length ; $pointer ++ )  <new_line>
                {  <new_line>
                    if ( $list[ $pointer - 1 ] eq $word_to_find )  <new_line>
                    {  <new_line>
                        if ( $action_name eq "get-position-of-word" )  <new_line>
                        {  <new_line>
                            $action_result = sprintf( "%d" , $pointer ) ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $action_result = "yes" ;  <new_line>
                        }  <new_line>
                        last ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  get-position-of-matching-text  <new_line>

        if ( $action_name eq "get-position-of-matching-text" )  <new_line>
        {  <new_line>
            $string_to_find = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            $string_to_search = $global_dashrep_replacement{ $operand_two } ;  <new_line>
            $search_starting_position = 0 ;  <new_line>
            $action_result = "0" ;  <new_line>
            $phrase_length = length( $string_to_search ) + 1 ;  <new_line>
            if ( $phrase_length > 0 )  <new_line>
            {  <new_line>
                $position = index( $string_to_search , $string_to_find , $search_starting_position ) + 1 ;  <new_line>
                if ( $position > 0 )  <new_line>
                {  <new_line>
                    $action_result = sprintf( "%d" , $position ) ;  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; action " . $action_name . " searched for " . $string_to_find . " within " . $string_to_search . " and found at character position " . $action_result . "}}\n";  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  generate-positions-of-delimiter  <new_line>

        if ( $action_name eq "generate-positions-of-delimiter" )  <new_line>
        {  <new_line>
            $string_to_find = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            $string_to_search = $global_dashrep_replacement{ $operand_two } ;  <new_line>
            $search_starting_position = 0 ;  <new_line>
            $list_of_positions = "" ;  <new_line>
            $phrase_length = length( $string_to_search ) + 1 ;  <new_line>
            if ( $phrase_length > 0 )  <new_line>
            {  <new_line>
                $local_endless_loop_counter = 0 ;  <new_line>
                $local_endless_loop_counter_maximum = 10000 ;  <new_line>
                $position = index( $string_to_search , $string_to_find , $search_starting_position ) ;  <new_line>
                while ( ( $position > -1 ) && ( $local_endless_loop_counter <= $local_endless_loop_counter_maximum ) )  <new_line>
                {  <new_line>
                    if ( $list_of_positions ne "" )  <new_line>
                    {  <new_line>
                        $list_of_positions .= " " ;  <new_line>
                    }  <new_line>
                    $list_of_positions .= sprintf( "%d" , ( $position + 1 ) ) ;  <new_line>
                    $search_starting_position = $position + 1 ;  <new_line>
                    $position = index( $string_to_search , $string_to_find , $search_starting_position ) ;  <new_line>
                    $local_endless_loop_counter ++ ;  <new_line>
                }  <new_line>
                $global_dashrep_replacement{ $operand_three } = $list_of_positions ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; action " . $action_name . " searched for " . $string_to_find . " within " . $string_to_search . " and found matches at character positions " . $action_result . "}}\n";  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  generate-positions-of-first-matching-delimiter-after-listed-positions  <new_line>

        if ( $action_name eq "generate-positions-of-first-matching-delimiter-after-listed-positions" )  <new_line>
        {  <new_line>
            $string_to_find = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            $string_to_search = $global_dashrep_replacement{ $operand_two } ;  <new_line>
            $list_of_positions = "" ;  <new_line>
            $phrase_length = length( $string_to_search ) + 1 ;  <new_line>
            if ( ( $phrase_length > 0 ) && ( exists( $global_dashrep_replacement{ $operand_three } ) ) )  <new_line>
            {  <new_line>
                $text_list_of_start_matching_positions = $global_dashrep_replacement{ $operand_three } ;  <new_line>
                $text_list_of_start_matching_positions =~ s/\n/ /sg ;  <new_line>
                $text_list_of_start_matching_positions =~ s/^ +// ;  <new_line>
                $text_list_of_start_matching_positions =~ s/ +$// ;  <new_line>
                if ( $text_list_of_start_matching_positions =~ /[0-9 ]+/ )  <new_line>
                {  <new_line>
                    @list_of_start_matching_positions = split( / +/ , $text_list_of_start_matching_positions ) ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    @list_of_start_matching_positions = ( ) ;  <new_line>
                }  <new_line>
                foreach $search_starting_position ( @list_of_start_matching_positions )  <new_line>
                {  <new_line>
                    $position = index( $string_to_search , $string_to_find , $search_starting_position ) ;  <new_line>
                    if ( $position < 0 )  <new_line>
                    {  <new_line>
                        $position = -1 ;  <new_line>
                    }  <new_line>
                    if ( $list_of_positions ne "" )  <new_line>
                    {  <new_line>
                        $list_of_positions .= " " ;  <new_line>
                    }  <new_line>
                    $list_of_positions .= sprintf( "%d" , ( $position + 1 ) ) ;  <new_line>
                }  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $operand_four } = $list_of_positions ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; action " . $action_name . " searched for " . $string_to_find . " within " . $string_to_search . " following postions " . $text_list_of_start_matching_positions . " and found matches at character positions " . $list_of_positions . "}}\n";  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  generate-positions-of-listed-words  <new_line>

        if ( $action_name eq "generate-positions-of-listed-words" )  <new_line>
        {  <new_line>
            $words_to_find = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            $string_to_search = $global_dashrep_replacement{ $operand_two } ;  <new_line>
            $list_of_positions = "" ;  <new_line>
            $words_to_find =~ s/\n/ /sg ;  <new_line>
            $words_to_find =~ s/^ +// ;  <new_line>
            $words_to_find =~ s/ +$// ;  <new_line>
            if ( $words_to_find =~ / / )  <new_line>
            {  <new_line>
                @list_of_text_items_to_find = split( / +/ , $words_to_find ) ;  <new_line>
                $number_of_items_to_find = $#list_of_text_items_to_find + 1 ;  <new_line>
            } elsif ( $words_to_find =~ /^[^ ]+$/ )  <new_line>
            {  <new_line>
                @list_of_text_items_to_find = ( ) ;  <new_line>
                $list_of_text_items_to_find[ 0 ] = $words_to_find ;  <new_line>
                $number_of_items_to_find = 1 ;  <new_line>
            } else  <new_line>
            {  <new_line>
                @list_of_text_items_to_find = ( ) ;  <new_line>
                $number_of_items_to_find = 0 ;  <new_line>
            }  <new_line>
            %text_to_find_at_position = ( ) ;  <new_line>
            if ( $number_of_items_to_find > 0 )  <new_line>
            {  <new_line>
                for ( $item_number = 1 ; $item_number <= $number_of_items_to_find ; $item_number ++ )  <new_line>
                {  <new_line>
                    $text_to_find = $list_of_text_items_to_find[ $item_number - 1 ] ;  <new_line>
                    $search_starting_position = 0 ;  <new_line>
                    $local_endless_loop_counter = 0 ;  <new_line>
                    $local_endless_loop_counter_maximum = 10000 ;  <new_line>
                    $position_of_text_found = index( $string_to_search , $text_to_find , $search_starting_position ) ;  <new_line>
                    while ( ( $position_of_text_found > -1 ) && ( $local_endless_loop_counter <= $local_endless_loop_counter_maximum ) )  <new_line>
                    {  <new_line>
                        $position_as_string = sprintf( "%05d" , $position_of_text_found ) ;  <new_line>
                        if ( exists( $text_to_find_at_position{ $position_as_string } ) )  <new_line>
                        {  <new_line>
                            if ( length( $text_to_find ) > length( $text_to_find_at_position{ $position_as_string } ) )  <new_line>
                            {  <new_line>
                                $text_to_find_at_position{ $position_as_string } = $text_to_find ;  <new_line>
                                $item_number_found_at_position{ $position_as_string } = $item_number ;  <new_line>
                            }  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $text_to_find_at_position{ $position_as_string } = $text_to_find ;  <new_line>
                            $item_number_found_at_position{ $position_as_string } = $item_number ;  <new_line>
                        }  <new_line>
                        $search_starting_position = $position_of_text_found + 1 ;  <new_line>
                        $position_of_text_found = index( $string_to_search , $text_to_find , $search_starting_position ) ;  <new_line>
                        $local_endless_loop_counter ++ ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            $position_end = -1 ;  <new_line>
            foreach $position_of_text_found ( sort( keys( %text_to_find_at_position ) ) )  <new_line>
            {  <new_line>
                if ( ( $position_of_text_found + 1 ) >= $position_end )  <new_line>
                {  <new_line>
                    if ( $list_of_positions ne "" )  <new_line>
                    {  <new_line>
                        $list_of_positions .= " " ;  <new_line>
                    }  <new_line>
                    $list_of_positions .= $position_of_text_found + 1 ;  <new_line>
                    $position_end = ( $position_of_text_found + length( $list_of_text_items_to_find[ $item_number_found_at_position{ $position_of_text_found } - 1 ] ) ) ;  <new_line>
                    $list_of_positions .= " " . $position_end  ;  <new_line>
                }  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $operand_three } = $list_of_positions ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; action " . $action_name . " searched for words in " . $operand_one . " within " . $operand_two . " and found matches at character positions in phrase " . $operand_three . "}}\n";  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  copy-words-found-in-both-lists  <new_line>
#      (sequence of first occurence of item in first list determines sequence in result list)  <new_line>
#  copy-words-found-only-in-first-list  <new_line>
#      (order of items in first list are preserved)  <new_line>
#  copy-words-unique-only  <new_line>

        if ( ( $action_name eq "copy-words-found-in-both-lists" ) || ( $action_name eq "copy-words-found-only-in-first-list" ) || ( $action_name eq "copy-words-unique-only" ) )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $text_list_loop = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $text_list_loop = "" ;  <new_line>
            }  <new_line>
            if ( $action_name eq "copy-words-unique-only" )  <new_line>
            {  <new_line>
                $text_list_key = "" ;  <new_line>
                $destination_phrase = $operand_two ;  <new_line>
            } else  <new_line>
            {  <new_line>
                if ( exists( $global_dashrep_replacement{ $operand_two } ) )  <new_line>
                {  <new_line>
                    $text_list_key = $global_dashrep_replacement{ $operand_two } ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $text_list_key = "" ;  <new_line>
                }  <new_line>
                $destination_phrase = $operand_three ;  <new_line>
            }  <new_line>
            $text_list_key =~ s/\n/ /sg ;  <new_line>
            $text_list_key =~ s/^ +// ;  <new_line>
            $text_list_key =~ s/ +$// ;  <new_line>
            if ( $text_list_key eq "" )  <new_line>
            {  <new_line>
                @list_of_key_values = ( ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                @list_of_key_values = split( / +/ , $text_list_key ) ;  <new_line>
            }  <new_line>
            %listed_word = ( ) ;  <new_line>
            foreach $word ( @list_of_key_values )  <new_line>
            {  <new_line>
                $listed_word{ $word } = 1 ;  <new_line>
            }  <new_line>
            $text_list_loop =~ s/\n/ /sg ;  <new_line>
            $text_list_loop =~ s/^ +// ;  <new_line>
            $text_list_loop =~ s/ +$// ;  <new_line>
            if ( $text_list_loop eq "" )  <new_line>
            {  <new_line>
                @list_of_loop_words = ( ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                @list_of_loop_words = split( / +/ , $text_list_loop ) ;  <new_line>
            }  <new_line>
            $length_of_loop_list = $#list_of_loop_words + 1 ;  <new_line>
            %occurrence_count_for_word = ( ) ;  <new_line>
            $number_of_unique_words = 0 ;  <new_line>
            @unique_word_at_position = ( ) ;  <new_line>
            $unique_word_at_position[ 0 ] = "" ;  <new_line>
            $text_list_of_unique_word_pointers = "" ;  <new_line>
            $result_word_list = "" ;  <new_line>
            if ( $length_of_loop_list > 0 )  <new_line>
            {  <new_line>
                for ( $pointer = 1 ; $pointer <= $length_of_loop_list ; $pointer ++ )  <new_line>
                {  <new_line>
                    $word = $list_of_loop_words[ $pointer - 1 ] ;  <new_line>
                    $occurrence_count_for_word{ $word } ++ ;  <new_line>
                    if ( exists( $listed_word{ $word } ) )  <new_line>
                    {  <new_line>
                        if ( ( $action_name eq "copy-words-found-in-both-lists" ) && ( $occurrence_count_for_word{ $word } == 1 ) )  <new_line>
                        {  <new_line>
                            $result_word_list .= $word . " " ;  <new_line>
                        }  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        if ( $action_name eq "copy-words-found-only-in-first-list" )  <new_line>
                        {  <new_line>
                            $result_word_list .= $word . " " ;  <new_line>
                        } elsif ( ( $action_name eq "copy-words-unique-only" ) && ( $occurrence_count_for_word{ $word } == 1 ) )  <new_line>
                        {  <new_line>
                            $result_word_list .= $word . " " ;  <new_line>
                            $number_of_unique_words ++ ;  <new_line>
                            $unique_word_at_position[ $number_of_unique_words ] = $word ;  <new_line>
                            $text_list_of_unique_word_pointers .= $pointer . " " ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            $text_list_of_unique_word_pointers =~ s/ +$// ;  <new_line>
            $result_word_list =~ s/ +$// ;  <new_line>
            $global_dashrep_replacement{ $destination_phrase } = $result_word_list ;  <new_line>
            if ( $action_name eq "copy-words-unique-only" )  <new_line>
            {  <new_line>
                $text_list_of_unique_word_counts = "" ;  <new_line>
                for ( $pointer = 1 ; $pointer <= $number_of_unique_words ; $pointer ++ )  <new_line>
                {  <new_line>
                    if ( $pointer > 1 )  <new_line>
                    {  <new_line>
                        $text_list_of_unique_word_counts .= " " ;  <new_line>
                    }  <new_line>
                    $text_list_of_unique_word_counts .= sprintf( "%d" , $occurrence_count_for_word{ $unique_word_at_position[ $pointer ] } ) ;  <new_line>
                }  <new_line>
                $global_dashrep_replacement{ "list-of-unique-word-counts" } = $text_list_of_unique_word_counts ;  <new_line>
                $global_dashrep_replacement{ "list-of-pointers-to-unique-words" } = $text_list_of_unique_word_pointers ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; action " . $action_name . " done" . "}}\n";  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  copy-words-found-in-either-list  <new_line>

        if ( $action_name eq "copy-words-found-in-either-list" )  <new_line>
        {  <new_line>
            $text_list_key = $global_dashrep_replacement{ $operand_one } . " " . $global_dashrep_replacement{ $operand_two } ;  <new_line>
            $text_list_key =~ s/\n/ /sg ;  <new_line>
            $text_list_key =~ s/^ +// ;  <new_line>
            $text_list_key =~ s/ +$// ;  <new_line>
            $result_word_list = "" ;  <new_line>
            if ( $text_list_key ne "" )  <new_line>
            {  <new_line>
                @list_of_key_values = split( / +/ , $text_list_key ) ;  <new_line>
                %listed_word = ( ) ;  <new_line>
                foreach $word ( @list_of_key_values )  <new_line>
                {  <new_line>
                    $listed_word{ $word } = "exists" ;  <new_line>
                }  <new_line>
                foreach $word ( keys( %listed_word ) )  <new_line>
                {  <new_line>
                    $result_word_list .= $word . " " ;  <new_line>
                }  <new_line>
            }  <new_line>
            $result_word_list =~ s/ +$// ;  <new_line>
            $global_dashrep_replacement{ $operand_three } = $result_word_list ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  generate-counts-from-integer-to-integer  <new_line>

        if ( $action_name eq "generate-counts-from-integer-to-integer" )  <new_line>
        {  <new_line>
            if ( $operand_one !~ /^[\-0-9]+$/ )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , invalid operand: " . $operand_one . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            if ( $operand_two !~ /^[\-0-9]+$/ )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , invalid operand: " . $operand_two . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            if ( ( $operand_one !~ /^[\-0-9]+$/ ) || ( $operand_two !~ /^[\-0-9]+$/ ) || ( $operand_three eq "" ) )  <new_line>
            {  <new_line>
                $do_nothing ++ ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $starting_count = $operand_one + 0 ;  <new_line>
                $ending_count = $operand_two + 0 ;  <new_line>
                $phrase_name = $operand_three ;  <new_line>
                if ( $starting_count > $ending_count )  <new_line>
                {  <new_line>
                    $plus_or_minus_one = -1 ;  <new_line>
                    $count_range = $starting_count - $ending_count + 1 ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $plus_or_minus_one = 1 ;  <new_line>
                    $count_range = $ending_count - $starting_count + 1 ;  <new_line>
                }  <new_line>
                if ( $count_range > 9999999 )  <new_line>
                {  <new_line>
                    $action_result = " " . $action_name . " " . $operands_all . " " ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $global_dashrep_replacement{ $phrase_name } = "" ;  <new_line>
                    for ( $counter = 1 ; $counter <= $count_range ; $counter ++ )  <new_line>
                    {  <new_line>
                        $next_number = $starting_count + ( $plus_or_minus_one * ( $counter - 1 ) );  <new_line>
                        if ( $next_number == 0 )  <new_line>
                        {  <new_line>
                            $text_to_append = "0" ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $text_to_append = sprintf( "%d" , $next_number ) ;  <new_line>
                        }  <new_line>
                        if ( $counter < $count_range )  <new_line>
                        {  <new_line>
                            $text_to_append .= " " ;  <new_line>
                        }  <new_line>
                        $global_dashrep_replacement{ $phrase_name } .= $text_to_append ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  generate-list-of-all-dashrep-phrases  <new_line>

        if ( $action_name eq "generate-list-of-all-dashrep-phrases" )  <new_line>
        {  <new_line>
            delete( $global_dashrep_replacement{ "list-of-phrases-newly-defined" } ) ;  <new_line>
            @list_of_phrases = keys( %global_dashrep_replacement ) ;  <new_line>
            @sequence_of_phrases = sort( @list_of_phrases ) ;  <new_line>
            $counter = 0 ;  <new_line>
            $global_dashrep_replacement{ $operand_one } = "" ;  <new_line>
            if ( $global_dashrep_replacement{ "yes-or-no-export-delimited-definitions" } eq "yes" )  <new_line>
            {  <new_line>
                foreach $phrase_name ( @sequence_of_phrases )  <new_line>
                {  <new_line>
                    if ( ( defined( $phrase_name ) ) && ( $phrase_name =~ /^[^ ]+$/ ) && ( exists( $global_dashrep_replacement{ $phrase_name } ) ) && ( $phrase_name ne "four-hyphens" ) )  <new_line>
                    {  <new_line>
                        if ( $global_dashrep_replacement{ $operand_one } ne "" )  <new_line>
                        {  <new_line>
                            $global_dashrep_replacement{ $operand_one } .= " " ;  <new_line>
                        }  <new_line>
                        $global_dashrep_replacement{ $operand_one } .= $phrase_name ;  <new_line>
                        $counter ++ ;  <new_line>
                    }  <new_line>
                }  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; wrote " . $counter . " phrase names to phrase " . $operand_one . "}}\n" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $operand_one } = "" ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; value of yes-or-no-export-delimited-definitions is not yes, so wrote no phrase names to phrase " . $operand_one . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  copy-words-that-begin-with-text  <new_line>

        if ( $action_name eq "copy-words-that-begin-with-text" )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $list_of_words_as_text = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $list_of_words_as_text = "" ;  <new_line>
            }  <new_line>
            $list_of_words_as_text =~ s/\n/ /sg ;  <new_line>
            $list_of_words_as_text =~ s/^ +// ;  <new_line>
            $list_of_words_as_text =~ s/ +$// ;  <new_line>
            if ( $list_of_words_as_text =~ / / )  <new_line>
            {  <new_line>
                @list_of_words = split( / +/ , $list_of_words_as_text ) ;  <new_line>
            } elsif ( $list_of_words_as_text eq "" )  <new_line>
            {  <new_line>
                @list_of_words = ( ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                @list_of_words = ( ) ;  <new_line>
                $list_of_words[ 0 ] = $list_of_words_as_text ;  <new_line>
            }  <new_line>
            $string_to_search = $global_dashrep_replacement{ $operand_three } ;  <new_line>
            $length_of_string = length( $string_to_search ) ;  <new_line>
            $generated_list = "" ;  <new_line>
            foreach $word ( @list_of_words )  <new_line>
            {  <new_line>
                if ( substr( $word , 0 , $length_of_string ) eq $string_to_search )  <new_line>
                {  <new_line>
                    $generated_list .= $word . " " ;  <new_line>
                }  <new_line>
            }  <new_line>
            $generated_list =~ s/ +$// ;  <new_line>
            $global_dashrep_replacement{ $operand_two } = $generated_list ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  copy-words-that-contain-listed-words  <new_line>
#  copy-words-that-begin-with-listed-words  <new_line>

        if ( ( $action_name eq "copy-words-that-contain-listed-words" ) || ( $action_name eq "copy-words-that-begin-with-listed-words" ) )  <new_line>
        {  <new_line>
            $list_of_words_as_text = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            $list_of_words_as_text =~ s/\n/ /sg ;  <new_line>
            $list_of_words_as_text =~ s/^ +// ;  <new_line>
            $list_of_words_as_text =~ s/ +$// ;  <new_line>
            @list_of_words_to_check = split( / +/ , $list_of_words_as_text ) ;  <new_line>
            $list_of_words_as_text = $global_dashrep_replacement{ $operand_three } ;  <new_line>
            $list_of_words_as_text =~ s/\n/ /sg ;  <new_line>
            $list_of_words_as_text =~ s/^ +// ;  <new_line>
            $list_of_words_as_text =~ s/ +$// ;  <new_line>
            @list_of_strings_to_match = split( / +/ , $list_of_words_as_text ) ;  <new_line>
            $generated_list = "" ;  <new_line>
            foreach $word_to_check ( @list_of_words_to_check )  <new_line>
            {  <new_line>
                foreach $string_to_match ( @list_of_strings_to_match )  <new_line>
                {  <new_line>
                    $pointer_to_matching_text = index( $word_to_check , $string_to_match ) ;  <new_line>
                    if ( $pointer_to_matching_text >= 0 )  <new_line>
                    {  <new_line>
                        if ( $action_name eq "copy-words-that-contain-listed-words" )  <new_line>
                        {  <new_line>
                            $generated_list .= $word_to_check . " " ;  <new_line>
                            last ;  <new_line>
                        } elsif ( ( $pointer_to_matching_text == 0 ) && ( $action_name eq "copy-words-that-begin-with-listed-words" ) )  <new_line>
                        {  <new_line>
                            $generated_list .= $word_to_check . " " ;  <new_line>
                            last ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            $generated_list =~ s/ +$// ;  <new_line>
            $global_dashrep_replacement{ $operand_two } = $generated_list ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  generate-every-pairwise-combination-of-words  <new_line>
#  generate-every-ordered-pairwise-combination-of-words  <new_line>

        if ( ( $action_name eq "generate-every-pairwise-combination-of-words" ) || ( $action_name eq "generate-every-ordered-pairwise-combination-of-words" ) )  <new_line>
        {  <new_line>
            $input_list_one_phrase_name = $operand_one ;  <new_line>
            $input_list_two_phrase_name = $operand_two ;  <new_line>
            $output_list_one_phrase_name = $operand_three ;  <new_line>
            $output_list_two_phrase_name = $operand_four ;  <new_line>
            $temp_text = $global_dashrep_replacement{ $input_list_one_phrase_name } ;  <new_line>
            $temp_text =~ s/\n/ /sg ;  <new_line>
            $temp_text =~ s/^ +// ;  <new_line>
            $temp_text =~ s/ +$// ;  <new_line>
            @input_list_one = split( / +/ , $temp_text ) ;  <new_line>
            $temp_text = $global_dashrep_replacement{ $input_list_two_phrase_name } ;  <new_line>
            $temp_text =~ s/\n/ /sg ;  <new_line>
            $temp_text =~ s/^ +// ;  <new_line>
            $temp_text =~ s/ +$// ;  <new_line>
            @input_list_two = split( / +/ , $temp_text ) ;  <new_line>
            $count_list_one = $#input_list_one + 1 ;  <new_line>
            $count_list_two = $#input_list_two + 1 ;  <new_line>
            if ( $count_list_one < 1 )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand " . $operand_one . " does not contain any words" . "}}\n" ;  <new_line>
                }  <new_line>
            } elsif ( $count_list_two < 1 )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . ", operand " . $operand_two . " does not contain any words" . "}}\n" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $output_list_one_phrase_name } = "" ;  <new_line>
                $global_dashrep_replacement{ $output_list_two_phrase_name } = "" ;  <new_line>
                $separator_one = " " ;  <new_line>
                $separator_two = " " ;  <new_line>
                $ending_first_count = $count_list_one ;  <new_line>
                $starting_second_count = 1 ;  <new_line>
                if ( $action_name eq "generate-every-ordered-pairwise-combination-of-words" )  <new_line>
                {  <new_line>
                    $ending_first_count -- ;  <new_line>
                }  <new_line>
                for ( $counter_one = 1 ; $counter_one <= $ending_first_count ; $counter_one ++ )  <new_line>
                {  <new_line>
                    $value_one = $input_list_one[ $counter_one - 1 ] ;  <new_line>
                    if ( $ending_first_count != $count_list_one )  <new_line>
                    {  <new_line>
                        $starting_second_count = $counter_one + 1 ;  <new_line>
                    }  <new_line>
                    for ( $counter_two = $starting_second_count ; $counter_two <= $count_list_two ; $counter_two ++ )  <new_line>
                    {  <new_line>
                        $value_two = $input_list_two[ $counter_two - 1 ] ;  <new_line>
                        if ( ( $counter_one == $ending_first_count ) && ( $counter_two == $count_list_two ) )  <new_line>
                        {  <new_line>
                            $separator_one = "" ;  <new_line>
                            $separator_two = "" ;  <new_line>
                        }  <new_line>
                        $global_dashrep_replacement{ $output_list_one_phrase_name } .= $value_one . $separator_one ;  <new_line>
                        $global_dashrep_replacement{ $output_list_two_phrase_name } .= $value_two . $separator_two ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  zero-one-multiple  <new_line>
#  zero-or-nonzero  <new_line>

        if ( ( $action_name eq "zero-one-multiple" ) || ( $action_name eq "zero-or-nonzero" ) )  <new_line>
        {  <new_line>
            if ( ( $operand_one =~ /^[0-9]+$/ ) && ( $operand_one + 0 <= 0 ) )  <new_line>
            {  <new_line>
                $action_result = "zero" ;  <new_line>
            } elsif ( $action_name eq "zero-or-nonzero" )  <new_line>
            {  <new_line>
                $action_result = "nonzero" ;  <new_line>
            } elsif ( $operand_one + 0 == 1 )  <new_line>
            {  <new_line>
                $action_result = "one" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $action_result = "multiple" ;  <new_line>
            }  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
#  end of action code  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  yes-or-no-empty-phrase  <new_line>

        if ( $action_name eq "yes-or-no-empty-phrase" )  <new_line>
        {  <new_line>
            $action_result = "yes" ;  <new_line>
            if ( $number_of_operands == 1 )  <new_line>
            {  <new_line>
                if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
                {  <new_line>
                    if ( $global_dashrep_replacement{ $operand_one } =~ /[^ \n]/ )  <new_line>
                    {  <new_line>
                        $action_result = "no" ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  get-count-of-characters  <new_line>

       if ( $action_name eq "get-count-of-characters" )  <new_line>
       {  <new_line>
            $action_result = "0" ;  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $action_result = length( $global_dashrep_replacement{ $operand_one } ) ;  <new_line>
                if ( $action_result < 1 )  <new_line>
                {  <new_line>
                    $action_result = "0" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  numeric-increment  <new_line>
#  numeric-decrement  <new_line>

       if ( ( $action_name eq "numeric-increment" ) || ( $action_name eq "numeric-decrement" ) )  <new_line>
       {  <new_line>
            $result_value = 0 ;  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) && ( $global_dashrep_replacement{ $operand_one } =~ /^ *-?[0-9]+ *$/ ) )  <new_line>
            {  <new_line>
                $result_value = int( $global_dashrep_replacement{ $operand_one } ) ;  <new_line>
            }  <new_line>
            if ( $action_name eq "numeric-increment" )  <new_line>
            {  <new_line>
                $result_value ++ ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $result_value -- ;  <new_line>
            }  <new_line>
            if ( $result_value == 0 )  <new_line>
            {  <new_line>
                $result_text = "0" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $result_text = sprintf( "%d" , $result_value ) ;  <new_line>
            }  <new_line>
            if ( $result_text =~ /^(-?[0-9]+)\.0*$/ )  <new_line>
            {  <new_line>
                $result_text = $1 ;  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $operand_one } = $result_text ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  yes-or-no-same-two-phrase-definitions  <new_line>

        if ( $action_name eq "yes-or-no-same-two-phrase-definitions" )  <new_line>
        {  <new_line>
            $action_result = "no" ;  <new_line>
            if ( ( not( exists( $global_dashrep_replacement{ $operand_one } ) ) ) && ( not( exists( $global_dashrep_replacement{ $operand_two } ) ) ) )  <new_line>
            {  <new_line>
                $action_result = "yes" ;  <new_line>
            } elsif ( not( exists( $global_dashrep_replacement{ $operand_one } ) ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ $operand_two } eq "" )  <new_line>
                {  <new_line>
                    $action_result = "yes" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = "no" ;  <new_line>
                }  <new_line>
            } elsif ( not( exists( $global_dashrep_replacement{ $operand_two } ) ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ $operand_one } eq "" )  <new_line>
                {  <new_line>
                    $action_result = "yes" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = "no" ;  <new_line>
                }  <new_line>
            } elsif ( ( $global_dashrep_replacement{ $operand_one } eq $global_dashrep_replacement{ $operand_two } ) )  <new_line>
            {  <new_line>
                $action_result = "yes" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $action_result = "no" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  yes-or-no-same-two-words  <new_line>

        if ( $action_name eq "yes-or-no-same-two-words" )  <new_line>
        {  <new_line>
            $action_result = "no" ;  <new_line>
            if ( $number_of_operands == 2 )  <new_line>
            {  <new_line>
                if ( $operand_one eq $operand_two )  <new_line>
                {  <new_line>
                    $action_result = "yes" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  get-characters-from-position-to-position  <new_line>

        if ( $action_name eq "get-characters-from-position-to-position" )  <new_line>
        {  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $string_in_phrase = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                $phrase_length = length( $string_in_phrase ) ;  <new_line>
                $starting_character_position = $operand_two + 0 ;  <new_line>
                if ( $starting_character_position > $phrase_length )  <new_line>
                {  <new_line>
                    $starting_character_position = $phrase_length ;  <new_line>
                } elsif ( $starting_character_position < 0 )  <new_line>
                {  <new_line>
                    $starting_character_position = $phrase_length - $starting_character_position + 1 ;  <new_line>
                }  <new_line>
                $ending_character_position = $operand_three + 0 ;  <new_line>
                if ( ( $ending_character_position > $phrase_length ) || ( $ending_character_position == 0 ) )  <new_line>
                {  <new_line>
                    $ending_character_position = $phrase_length ;  <new_line>
                } elsif ( $ending_character_position < 0 )  <new_line>
                {  <new_line>
                    $ending_character_position = $phrase_length - $ending_character_position + 1 ;  <new_line>
                }  <new_line>
                $number_of_characters_to_get = $ending_character_position - $starting_character_position + 1 ;  <new_line>
                if ( $number_of_characters_to_get < 1 )  <new_line>
                {  <new_line>
                    $number_of_characters_to_get = 1 ;  <new_line>
                }  <new_line>
                $action_result = substr( $string_in_phrase , ( $starting_character_position - 1 ) , $number_of_characters_to_get ) ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; action " . $action_name . " got characters " . $action_result . "}}\n";  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  numeric-minus  <new_line>

        if ( $action_name eq "numeric-minus" )  <new_line>
        {  <new_line>
            $numeric_value = ( $operand_one + 0 ) - ( $operand_two + 0 ) ;  <new_line>
            if ( $numeric_value == 0 )  <new_line>
            {  <new_line>
                $action_result = "0" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $action_result = sprintf( "%f" , $numeric_value ) ;  <new_line>
            }  <new_line>
            if ( $action_result =~ /^(-?[0-9]+)\.0*$/ )  <new_line>
            {  <new_line>
                $action_result = $1 ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  numeric-divide-by  <new_line>

        if ( $action_name eq "numeric-divide-by" )  <new_line>
        {  <new_line>
            if ( ( $operand_two + 0 ) == 0 )  <new_line>
            {  <new_line>
                $action_result = "infinity" ;  <new_line>
            } elsif ( ( $operand_one + 0 ) == 0 )  <new_line>
            {  <new_line>
                $action_result = "0" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $numeric_value = ( $operand_one + 0 ) / ( $operand_two + 0 ) ;  <new_line>
                $action_result = sprintf( "%f" , $numeric_value ) ;  <new_line>
            }  <new_line>
            if ( $action_result =~ /^(-?[0-9]+)\.0*$/ )  <new_line>
            {  <new_line>
                $action_result = $1 ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; operands for action " . $action_name . " are " . $operand_one . " and " . $operand_two . " , and result is " . $numeric_value . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  numeric-add  <new_line>
#  numeric-multiply  <new_line>
#  numeric-maximum  <new_line>
#  numeric-minimum  <new_line>

        if ( ( $action_name eq "numeric-add" ) || ( $action_name eq "numeric-multiply" ) || ( $action_name eq "numeric-maximum" ) || ( $action_name eq "numeric-minimum" ) )  <new_line>
        {  <new_line>
            $action_result = "0" ;  <new_line>
            if ( $action_name eq "numeric-add" )  <new_line>
            {  <new_line>
                $numeric_value = 0 ;  <new_line>
            } elsif ( $action_name eq "numeric-multiply" )  <new_line>
            {  <new_line>
                $numeric_value = 1 ;  <new_line>
            } elsif ( $action_name eq "numeric-maximum" )  <new_line>
            {  <new_line>
                $numeric_value = -999999 ;  <new_line>
            } elsif ( $action_name eq "numeric-minimum" )  <new_line>
            {  <new_line>
                $numeric_value = 999999 ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $numeric_value = 0 ;  <new_line>
            }  <new_line>
            $temp_text = $operands_all ;  <new_line>
            @list = split( /[ \n]+/ , $temp_text ) ;  <new_line>
            for ( $counter = 0 ; $counter <= $#list ; $counter ++ )  <new_line>
            {  <new_line>
                $value = $list[ $counter ] ;  <new_line>
                if ( $value =~ /^-?[0-9]+(\.[0-9]*)?$/ )  <new_line>
                {  <new_line>
                    if ( $action_name eq "numeric-add" )  <new_line>
                    {  <new_line>
                        $numeric_value = $numeric_value + $value ;  <new_line>
                    } elsif ( $action_name eq "numeric-multiply" )  <new_line>
                    {  <new_line>
                        $numeric_value = $numeric_value * $value ;  <new_line>
                    } elsif ( $action_name eq "numeric-maximum" )  <new_line>
                    {  <new_line>
                        if ( $value > $numeric_value )  <new_line>
                        {  <new_line>
                            $numeric_value = $value ;  <new_line>
                        }  <new_line>
                    } elsif ( $action_name eq "numeric-minimum" )  <new_line>
                    {  <new_line>
                        if ( $value < $numeric_value )  <new_line>
                        {  <new_line>
                            $numeric_value = $value ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $numeric_value == 0 )  <new_line>
            {  <new_line>
                $action_result = "0" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $action_result = sprintf( "%f" , $numeric_value ) ;  <new_line>
            }  <new_line>
            if ( $action_result =~ /^(-?[0-9]+)\.0*$/ )  <new_line>
            {  <new_line>
                $action_result = $1 ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  numeric-absolute  <new_line>

        if ( $action_name eq "numeric-absolute" )  <new_line>
        {  <new_line>
            $result_value = abs( $operand_one + 0 ) ;  <new_line>
            if ( $result_value == 0 )  <new_line>
            {  <new_line>
                $action_result = "0" ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $action_result = sprintf( "%d" , $result_value ) ;  <new_line>
            }  <new_line>
            if ( $action_result =~ /^(-?[0-9]+)\.0*$/ )  <new_line>
            {  <new_line>
                $action_result = $1 ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  numeric-integer  <new_line>
#  numeric-odd-or-even  <new_line>
#  numeric-sine  <new_line>
#  numeric-cosine  <new_line>
#  numeric-logarithm-base-e  <new_line>
#  numeric-logarithm-base-10  <new_line>
#  numeric-y-map-tile-number-based-on-latitude  <new_line>

        if ( ( $action_name eq "numeric-integer" ) || ( $action_name eq "numeric-sine" ) || ( $action_name eq "numeric-cosine" ) || ( $action_name eq "numeric-logarithm-base-e" ) || ( $action_name eq "numeric-logarithm-base-10" ) || ( $action_name eq "numeric-y-map-tile-number-based-on-latitude" )|| ( $action_name eq "numeric-odd-or-even" ) )  <new_line>
        {  <new_line>
            if ( $action_name eq "numeric-integer" )  <new_line>
            {  <new_line>
                $result_value = int( $operand_one + 0 ) ;  <new_line>
                if ( $result_value == 0 )  <new_line>
                {  <new_line>
                    $action_result = "0" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = sprintf( "%d" , $result_value ) ;  <new_line>
                }  <new_line>
                if ( $action_result =~ /^(-?[0-9]+)\.0*$/ )  <new_line>
                {  <new_line>
                    $action_result = $1 ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "numeric-odd-or-even" )  <new_line>
            {  <new_line>
                $result_value = int( $operand_one + 0 ) ;  <new_line>
                $result_value = $result_value - int( ( $result_value * 2 ) / 2 ) ;  <new_line>
                if ( $result_value == 0 )  <new_line>
                {  <new_line>
                    $action_result = "even" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = "odd" ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "numeric-sine" )  <new_line>
            {  <new_line>
                $result_value = sin( $operand_one + 0.0 ) ;  <new_line>
                if ( $result_value == 0 )  <new_line>
                {  <new_line>
                    $action_result = "0" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = sprintf( "%f" , $result_value ) ;  <new_line>
                }  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; for action " . $action_name . " and input value " . $operand_one . " , result is " . $result_value . "}}\n" ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "numeric-cosine" )  <new_line>
            {  <new_line>
                $result_value = cos( $operand_one + 0.0 ) ;  <new_line>
                if ( $result_value == 0 )  <new_line>
                {  <new_line>
                    $action_result = "0" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = sprintf( "%f" , $result_value ) ;  <new_line>
                }  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; for action " . $action_name . " and input value " . $operand_one . " , result is " . $result_value . "}}\n" ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "numeric-logarithm-base-e" )  <new_line>
            {  <new_line>
                if ( $operand_one + 0.0 < 0.000001 )  <new_line>
                {  <new_line>
                    $result_value = -999999 ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $result_value = log( $operand_one + 0.0 ) ;  <new_line>
                }  <new_line>
                if ( $result_value == 0 )  <new_line>
                {  <new_line>
                    $action_result = "0" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = sprintf( "%f" , $result_value ) ;  <new_line>
                }  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; for action " . $action_name . " and input value " . $operand_one . " , result is " . $result_value . "}}\n" ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "numeric-logarithm-base-10" )  <new_line>
            {  <new_line>
                if ( $operand_one + 0.0 < 0.000001 )  <new_line>
                {  <new_line>
                    $result_value = -999999 ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $result_value = ( log( $operand_one + 0.0 ) ) / ( log( 10.0 ) ) ;  <new_line>
                }  <new_line>
                if ( $result_value == 0 )  <new_line>
                {  <new_line>
                    $action_result = "0" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = sprintf( "%f" , $result_value ) ;  <new_line>
                }  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; for action " . $action_name . " and input value " . $operand_one . " , result is " . $result_value . "}}\n" ;  <new_line>
                }  <new_line>
            } elsif ( $action_name eq "numeric-y-map-tile-number-based-on-latitude" )  <new_line>
            {  <new_line>
                if ( ( $operand_one > 85.0 ) || ( $operand_one < -85.0 ) )  <new_line>
                {  <new_line>
                    $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
                    $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; warning, for action " . $action_name . " , angle is outside of valid range: " . $operand_one . "}}\n" ;  <new_line>
                    }  <new_line>
                    next ;  <new_line>
                }  <new_line>
                if ( ( exists( $global_dashrep_replacement{ "numeric-map-tile-zoom" } ) ) && ( $global_dashrep_replacement{ "numeric-map-tile-zoom" } =~ /^[0-9]+$/ ) )  <new_line>
                {  <new_line>
                    $map_tile_zoom = $global_dashrep_replacement{ "numeric-map-tile-zoom" } + 0 ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $map_tile_zoom = 16 ;  <new_line>
                }  <new_line>
                $map_tile_n = 2 ** $map_tile_zoom ;  <new_line>
                $pi = 4.0 * atan2( 1.0 , 1.0 ) ;  <new_line>
                $global_dashrep_replacement{ "numeric-pi" } = sprintf( "%f" , $pi ) ;  <new_line>
                $angle_in_radians = ( $operand_one + 0.0 ) * $pi / 180.0 ;  <new_line>
                $sine_of_angle = sin( $angle_in_radians ) ;  <new_line>
                $cosine_of_angle = cos( $angle_in_radians ) ;  <new_line>
                $result_value = $map_tile_n * ( 1.0 - ( log( ( $sine_of_angle / $cosine_of_angle ) + ( 1 / $cosine_of_angle ) ) / $pi ) ) / 2.0 ;  <new_line>
                if ( $result_value == 0 )  <new_line>
                {  <new_line>
                    $action_result = "0" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $action_result = sprintf( "%f" , $result_value ) ;  <new_line>
                }  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; for action " . $action_name . " and input value " . $operand_one . " , result is " . $result_value . "}}\n" ;  <new_line>
                    $global_trace_log .= "{{trace; calculation details, zoom = " . $map_tile_zoom . " , n = " . $map_tile_n . " , angle in radians = " . $angle_in_radians . " , sine = " . $sine_of_angle . " , cosine = " . $cosine_of_angle . " , pi = " . $pi . "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $action_result =~ /^(-?[0-9]+)\.0*$/ )  <new_line>
            {  <new_line>
                $action_result = $1 ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  numeric-vector-add-number  <new_line>
#  numeric-vector-multiply-by-number  <new_line>
#  numeric-vectors-add  <new_line>
#  numeric-vectors-multiply  <new_line>
#  numeric-vectors-divide-by  <new_line>
#  numeric-vectors-from-delta-values-calculate-distances  <new_line>
#  numeric-vector-integers  <new_line>
#  numeric-vector-absolutes  <new_line>
#  <new_line>
#  Reminder: target phrase name might be the same as the source phrase name  <new_line>

        if ( ( $action_name eq "numeric-vector-add-number" ) || ( $action_name eq "numeric-vector-multiply-by-number" ) || ( $action_name eq "numeric-vectors-add" ) ||  ( $action_name eq "numeric-vectors-multiply" ) ||  ( $action_name eq "numeric-vectors-divide-by" ) || ( $action_name eq "numeric-vectors-from-delta-values-calculate-distances" ) || ( $action_name eq "numeric-vector-integers" ) || ( $action_name eq "numeric-vector-absolutes" ) )  <new_line>
        {  <new_line>
            $single_value = 0 ;  <new_line>
            $required_number_of_operands = $global_required_number_of_operands_for_action{ $action_name } ;  <new_line>
            if ( $required_number_of_operands == 3 )  <new_line>
            {  <new_line>
                $target_operand = $operand_three ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $target_operand = $operand_two ;  <new_line>
            }  <new_line>
            if ( ( $action_name eq "numeric-vector-add-number" ) || ( $action_name eq "numeric-vector-multiply-by-number" ) )  <new_line>
            {  <new_line>
                $single_value = $operand_two + 0 ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ $operand_one } !~ /^[ \-0-9\.]+$/ )  <new_line>
            {  <new_line>
                $action_result = $global_dashrep_replacement{ "dashrep-undefined" } ;  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , invalid operand: " . $operand_one . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            $list_of_x_values_as_text = $global_dashrep_replacement{ $operand_one } ;  <new_line>
            $list_of_x_values_as_text =~ s/\n/ /s ;  <new_line>
            $list_of_x_values_as_text =~ s/^ +// ;  <new_line>
            $list_of_x_values_as_text =~ s/ +$// ;  <new_line>
            @list_of_x_values = split( / +/ , $list_of_x_values_as_text ) ;  <new_line>
            $global_dashrep_replacement{ $target_operand } = "" ;  <new_line>
            if ( ( $action_name eq "numeric-vectors-add" ) || ( $action_name eq "numeric-vectors-multiply" ) || ( $action_name eq "numeric-vectors-divide-by" ) || ( $action_name eq "numeric-vectors-from-delta-values-calculate-distances" ) )  <new_line>
            {  <new_line>
                $list_of_y_values_as_text = $global_dashrep_replacement{ $operand_two } ;  <new_line>
                $list_of_y_values_as_text =~ s/\n/ /s ;  <new_line>
                $list_of_y_values_as_text =~ s/^ +// ;  <new_line>
                $list_of_y_values_as_text =~ s/ +$// ;  <new_line>
                @list_of_y_values = split( / +/ , $list_of_y_values_as_text ) ;  <new_line>
            }  <new_line>
            for( $pair_pointer = 0 ; $pair_pointer <= $#list_of_x_values ; $pair_pointer ++ )  <new_line>
            {  <new_line>
                if ( $action_name eq "numeric-vectors-add" )  <new_line>
                {  <new_line>
                    $numeric_value = $list_of_x_values[ $pair_pointer ] + $list_of_y_values[ $pair_pointer ] + 0 ;  <new_line>
                } elsif ( $action_name eq "numeric-vectors-multiply" )  <new_line>
                {  <new_line>
                    $numeric_value = $list_of_x_values[ $pair_pointer ] * $list_of_y_values[ $pair_pointer ] + 0 ;  <new_line>
                } elsif ( $action_name eq "numeric-vectors-divide-by" )  <new_line>
                {  <new_line>
                    if ( abs( $list_of_y_values[ $pair_pointer ] ) < 0.000001 )  <new_line>
                    {  <new_line>
                        $numeric_value = 1000000 ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        $numeric_value = $list_of_x_values[ $pair_pointer ] / $list_of_y_values[ $pair_pointer ] + 0 ;  <new_line>
                    }  <new_line>
                } elsif ( $action_name eq "numeric-vectors-from-delta-values-calculate-distances" )  <new_line>
                {  <new_line>
                    $numeric_value =  int( sqrt( ( $list_of_x_values[ $pair_pointer ] ** 2 ) + ( $list_of_y_values[ $pair_pointer ] ** 2 ) ) + 0.5 ) ;  <new_line>
                } elsif ( $action_name eq "numeric-vector-add-number" )  <new_line>
                {  <new_line>
                    $numeric_value = $list_of_x_values[ $pair_pointer ] + $single_value + 0 ;  <new_line>
                } elsif ( $action_name eq "numeric-vector-multiply-by-number" )  <new_line>
                {  <new_line>
                    $numeric_value = $list_of_x_values[ $pair_pointer ] * $single_value ;  <new_line>
                } elsif ( $action_name eq "numeric-vector-integers" )  <new_line>
                {  <new_line>
                    $numeric_value = int( $list_of_x_values[ $pair_pointer ] + 0 ) ;  <new_line>
                } elsif ( $action_name eq "numeric-vector-absolutes" )  <new_line>
                {  <new_line>
                    $numeric_value = abs( $list_of_x_values[ $pair_pointer ] + 0 ) ;  <new_line>
                }  <new_line>
                if ( $numeric_value == 0 )  <new_line>
                {  <new_line>
                    $global_dashrep_replacement{ $target_operand } .= "0 " ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $global_dashrep_replacement{ $target_operand } .= sprintf( "%d" , $numeric_value ) . " " ;  <new_line>
                }  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $operand_three } =~ s/ +$// ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; action " . $action_name . " did vector calculations" . "}}\n";  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  numeric-two-dimensional-sort-into-columns-and-rows  <new_line>
#  <new_line>
#  operand order:  <new_line>
#    number of columns  <new_line>
#    word-based (space-delimited) list of column-direction values for sorting (increasing to right)  <new_line>
#    word-based (space-delimited) list of row-direction values for sorting (increasing to top)  <new_line>
#    name of phrase into which to put the results, which are space-delimited strings such as "row-3-column-2" and "row-1-column-1"  <new_line>
#  <new_line>
#  number of rows is calculated based on number of values  <new_line>

        if ( $action_name eq "numeric-two-dimensional-sort-into-columns-and-rows" )  <new_line>
        {  <new_line>
            if ( ( $operand_one + 0 ) < 1 )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , number of columns (" . $operand_one . ") is less than 1" . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ $operand_two } !~ /^[\-0-9\. ]+$/ )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , second operand contains invalid values: " . $global_dashrep_replacement{ $operand_two } . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ $operand_three } !~ /^[\-0-9\. ]+$/ )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , third operand contains invalid values: " . $global_dashrep_replacement{ $operand_three } . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            $number_of_columns = $operand_one ;  <new_line>
            $text_for_right_direction_values = $global_dashrep_replacement{ $operand_two } ;  <new_line>
            $text_for_up_direction_values = $global_dashrep_replacement{ $operand_three } ;  <new_line>
            $text_for_up_direction_values =~ s/\n/ /s ;  <new_line>
            $text_for_up_direction_values =~ s/^ +// ;  <new_line>
            $text_for_up_direction_values =~ s/ +$// ;  <new_line>
            $text_for_right_direction_values =~ s/\n/ /s ;  <new_line>
            $text_for_right_direction_values =~ s/^ +// ;  <new_line>
            $text_for_right_direction_values =~ s/ +$// ;  <new_line>
            @up_direction_value_for_item_number = split( / +/ , $text_for_up_direction_values ) ;  <new_line>
            unshift( @up_direction_value_for_item_number , 0 ) ;  <new_line>
            @right_direction_value_for_item_number = split( / +/ , $text_for_right_direction_values ) ;  <new_line>
            unshift( @right_direction_value_for_item_number , 0 ) ;  <new_line>
            $number_of_items = $#up_direction_value_for_item_number ;  <new_line>
            if ( ( $#up_direction_value_for_item_number != $#right_direction_value_for_item_number ) && ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" ) )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , second operand (" . $operand_two . ") and third operand (". $operand_three . ") do not have the same number of values" . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            if ( ( $number_of_items == 0 ) && ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" ) )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , the second operand (" . $operand_two . ") and third operand (". $operand_three . ") are empty" . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            $number_of_items_in_bottom_row = $number_of_columns ;  <new_line>
            $number_of_full_rows = int( $number_of_items / $number_of_columns ) ;  <new_line>
            $number_of_rows = $number_of_full_rows ;  <new_line>
            if ( ( $number_of_full_rows * $number_of_columns ) < $number_of_items )  <new_line>
            {  <new_line>
                $number_of_rows ++ ;  <new_line>
                $number_of_items_in_bottom_row = $number_of_items - ( $number_of_full_rows * $number_of_columns ) ;  <new_line>
            }  <new_line>
            @list_of_remaining_item_numbers = ( ) ;  <new_line>
            $up_direction_minimum_value = 999999 ;  <new_line>
            $up_direction_maximum_value = -999999 ;  <new_line>
            $right_direction_minimum_value = 999999 ;  <new_line>
            $right_direction_maximum_value = -999999 ;  <new_line>
            for ( $item_number = 1 ; $item_number <= $number_of_items ; $item_number ++ )  <new_line>
            {  <new_line>
                $zero_if_not_remaining_item_number[ $item_number ] = $item_number ;  <new_line>
                if ( $up_direction_value_for_item_number[ $item_number ] < $up_direction_minimum_value )  <new_line>
                {  <new_line>
                    $up_direction_minimum_value = $up_direction_value_for_item_number[ $item_number ] ;  <new_line>
                }  <new_line>
                if ( $up_direction_value_for_item_number[ $item_number ] > $up_direction_maximum_value )  <new_line>
                {  <new_line>
                    $up_direction_maximum_value = $up_direction_value_for_item_number[ $item_number ] ;  <new_line>
                }  <new_line>
                if ( $right_direction_value_for_item_number[ $item_number ] < $right_direction_minimum_value )  <new_line>
                {  <new_line>
                    $right_direction_minimum_value = $right_direction_value_for_item_number[ $item_number ] ;  <new_line>
                }  <new_line>
                if ( $right_direction_value_for_item_number[ $item_number ] > $right_direction_maximum_value )  <new_line>
                {  <new_line>
                    $right_direction_maximum_value = $right_direction_value_for_item_number[ $item_number ] ;  <new_line>
                }  <new_line>
                push( @list_of_remaining_item_numbers , $item_number ) ;  <new_line>
            }  <new_line>
            $range_of_up_direction_values = $up_direction_maximum_value - $up_direction_minimum_value ;  <new_line>
            $range_of_right_direction_values = $right_direction_maximum_value - $right_direction_minimum_value ;  <new_line>
            if ( $range_of_up_direction_values > 0.0001 )  <new_line>
            {  <new_line>
                $multiplier_for_up_direction_values = $number_of_rows * 100.00 / $range_of_up_direction_values ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $multiplier_for_up_direction_values = $number_of_rows * 1.0 ;  <new_line>
                $up_direction_minimum_value = $up_direction_minimum_value - 1.0 ;  <new_line>
            }  <new_line>
            if ( $range_of_right_direction_values > 0.0001 )  <new_line>
            {  <new_line>
                $multiplier_for_right_direction_values = $number_of_columns * 100.00 / $range_of_right_direction_values ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $multiplier_for_right_direction_values = $number_of_columns * 1.0 ;  <new_line>
                $right_direction_minimum_value = $right_direction_minimum_value - 1.0 ;  <new_line>
            }  <new_line>
            for ( $item_number = 1 ; $item_number <= $number_of_items ; $item_number ++ )  <new_line>
            {  <new_line>
                $up_direction_value_for_item_number[ $item_number ] = ( $up_direction_value_for_item_number[ $item_number ] - $up_direction_minimum_value ) * $multiplier_for_up_direction_values ;  <new_line>
                $right_direction_value_for_item_number[ $item_number ] = ( $right_direction_value_for_item_number[ $item_number ] - $right_direction_minimum_value ) * $multiplier_for_right_direction_values ;  <new_line>
            }  <new_line>
            for ( $item_number = 1 ; $item_number <= $number_of_items ; $item_number ++ )  <new_line>
            {  <new_line>
                $right_and_up_direction_value_for_item_number[ $item_number ] = $right_direction_value_for_item_number[ $item_number ] + $up_direction_value_for_item_number[ $item_number ] ;  <new_line>
                $left_and_up_direction_value_for_item_number[ $item_number ] = - $right_direction_value_for_item_number[ $item_number ] + $up_direction_value_for_item_number[ $item_number ] ;  <new_line>
            }  <new_line>
            $top_row_number = 1 ;  <new_line>
            $bottom_row_number = $number_of_rows ;  <new_line>
            $fill_direction_top_left = 1 ;  <new_line>
            $fill_direction_bottom_right = 2 ;  <new_line>
            $fill_direction_bottom_left = 3 ;  <new_line>
            $fill_direction_top_right = 4 ;  <new_line>
            $need_maximum = 1 ;  <new_line>
            $need_minimum = 2 ;  <new_line>
            $value_direction_right_and_up = 1 ;  <new_line>
            $value_direction_left_and_up = 2 ;  <new_line>
            $value_direction_up = 3 ;  <new_line>
            $value_direction_right = 4 ;  <new_line>
            $top_left_open_column = 1 ;  <new_line>
            $top_right_open_column = $number_of_columns ;  <new_line>
            $bottom_left_open_column = 1 ;  <new_line>
            $bottom_right_open_column = $number_of_items_in_bottom_row ;  <new_line>
            $number_of_items_remaining = $number_of_items ;  <new_line>
            while ( $number_of_items_remaining > 0 )  <new_line>
            {  <new_line>
                for ( $fill_direction = $fill_direction_top_left ; $fill_direction <= $fill_direction_top_right ; $fill_direction ++ )  <new_line>
                {  <new_line>
                    if ( $fill_direction == $fill_direction_top_left )  <new_line>
                    {  <new_line>
                        $target_row_number = $top_row_number ;  <new_line>
                        $target_column_number = $top_left_open_column ;  <new_line>
                        if ( $top_row_number == $bottom_row_number )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_minimum ;  <new_line>
                            $use_value_direction = $value_direction_right ;  <new_line>
                        } elsif ( $top_left_open_column < $top_right_open_column )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_maximum ;  <new_line>
                            $use_value_direction = $value_direction_left_and_up ;  <new_line>
                        } elsif ( $top_left_open_column == $top_right_open_column )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_maximum ;  <new_line>
                            $use_value_direction = $value_direction_up ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            next ;  <new_line>
                        }  <new_line>
                    } elsif ( $fill_direction == $fill_direction_bottom_right )  <new_line>
                    {  <new_line>
                        $target_row_number = $bottom_row_number ;  <new_line>
                        $target_column_number = $bottom_right_open_column ;  <new_line>
                        if ( $top_row_number == $bottom_row_number )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_maximum ;  <new_line>
                            $use_value_direction = $value_direction_right ;  <new_line>
                        } elsif ( ( $bottom_row_number == $number_of_rows ) && ( $bottom_right_open_column > $number_of_items_in_bottom_row ) )  <new_line>
                        {  <new_line>
                            $bottom_right_open_column -- ;  <new_line>
                            next ;  <new_line>
                        } elsif ( $bottom_left_open_column < $bottom_right_open_column )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_minimum ;  <new_line>
                            $use_value_direction = $value_direction_left_and_up ;  <new_line>
                        } elsif ( $bottom_left_open_column == $bottom_right_open_column )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_minimum ;  <new_line>
                            $use_value_direction = $value_direction_up ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            next ;  <new_line>
                        }  <new_line>
                    } elsif ( $fill_direction == $fill_direction_bottom_left )  <new_line>
                    {  <new_line>
                        $target_row_number = $bottom_row_number ;  <new_line>
                        $target_column_number = $bottom_left_open_column ;  <new_line>
                        if ( $top_row_number == $bottom_row_number )  <new_line>
                        {  <new_line>
                            next ;  <new_line>
                        } elsif ( ( $bottom_row_number == $number_of_rows ) && ( $bottom_left_open_column > $number_of_items_in_bottom_row ) )  <new_line>
                        {  <new_line>
                            $bottom_row_number -- ;  <new_line>
                            $bottom_left_open_column = 1 ;  <new_line>
                            $bottom_right_open_column = $number_of_columns ;  <new_line>
                            $need_maximum_or_minimum = $need_minimum ;  <new_line>
                            $use_value_direction = $value_direction_right_and_up ;  <new_line>
                        } elsif ( $bottom_left_open_column < $bottom_right_open_column )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_minimum ;  <new_line>
                            $use_value_direction = $value_direction_right_and_up ;  <new_line>
                        } elsif ( $bottom_left_open_column == $bottom_right_open_column )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_minimum ;  <new_line>
                            $use_value_direction = $value_direction_up ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            next ;  <new_line>
                        }  <new_line>
                    } elsif ( $fill_direction == $fill_direction_top_right )  <new_line>
                    {  <new_line>
                        $target_row_number = $top_row_number ;  <new_line>
                        $target_column_number = $top_right_open_column ;  <new_line>
                        if ( $top_row_number == $bottom_row_number )  <new_line>
                        {  <new_line>
                            next ;  <new_line>
                        } elsif ( $top_left_open_column < $top_right_open_column )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_maximum ;  <new_line>
                            $use_value_direction = $value_direction_left_and_up ;  <new_line>
                        } elsif ( $top_left_open_column == $top_right_open_column )  <new_line>
                        {  <new_line>
                            $need_maximum_or_minimum = $need_maximum ;  <new_line>
                            $use_value_direction = $value_direction_up ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            next ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                    if ( $need_maximum_or_minimum == $need_maximum )  <new_line>
                    {  <new_line>
                        $max_or_min_value = -999999 ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        $max_or_min_value = 999999 ;  <new_line>
                    }  <new_line>
                    $item_number_at_min_or_max = 0 ;  <new_line>
                    foreach ( $item_number = 1 ; $item_number <= $number_of_items ; $item_number ++ )  <new_line>
                    {  <new_line>
                        if ( $zero_if_not_remaining_item_number[ $item_number ] >= 1 )  <new_line>
                        {  <new_line>
                            if ( $use_value_direction == $value_direction_right_and_up )  <new_line>
                            {  <new_line>
                                $next_value_to_compare = $right_and_up_direction_value_for_item_number[ $item_number ] ;  <new_line>
                            } elsif ( $use_value_direction == $value_direction_left_and_up )  <new_line>
                            {  <new_line>
                                $next_value_to_compare = $left_and_up_direction_value_for_item_number[ $item_number ] ;  <new_line>
                            } elsif ( $use_value_direction == $value_direction_up )  <new_line>
                            {  <new_line>
                                $next_value_to_compare = $up_direction_value_for_item_number[ $item_number ] ;  <new_line>
                            } elsif ( $use_value_direction == $value_direction_right )  <new_line>
                            {  <new_line>
                                $next_value_to_compare = $right_direction_value_for_item_number[ $item_number ] ;  <new_line>
                            } else  <new_line>
                            {  <new_line>
                                next ;  <new_line>
                            }  <new_line>
                            if ( $need_maximum_or_minimum == $need_maximum )  <new_line>
                            {  <new_line>
                                if ( $next_value_to_compare > $max_or_min_value )  <new_line>
                                {  <new_line>
                                    $max_or_min_value = $next_value_to_compare ;  <new_line>
                                    $item_number_at_min_or_max = $item_number ;  <new_line>
                                }  <new_line>
                            } else  <new_line>
                            {  <new_line>
                                if ( $next_value_to_compare < $max_or_min_value )  <new_line>
                                {  <new_line>
                                    $max_or_min_value = $next_value_to_compare ;  <new_line>
                                    $item_number_at_min_or_max = $item_number ;  <new_line>
                                }  <new_line>
                            }  <new_line>
                        }  <new_line>
                    }  <new_line>
                    $column_position_for_item_number[ $item_number_at_min_or_max ] = $target_column_number ;  <new_line>
                    $row_position_for_item_number[ $item_number_at_min_or_max ] = $target_row_number ;  <new_line>
                    if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; 2-d info: " . $item_number_at_min_or_max . " " . $target_row_number . " " . $target_column_number . " " . $top_row_number . " " . $bottom_row_number . " " . $top_left_open_column . " " . $top_right_open_column . " " . $bottom_left_open_column . " " . $bottom_right_open_column . " " . $fill_direction . " " . $need_maximum_or_minimum . "}}\n" ;  <new_line>
                    }  <new_line>
#                   Do NOT change (or remove) next line, else endless loop is likely:  <new_line>
                    $number_of_items_remaining -- ;  <new_line>
                    if ( $number_of_items_remaining < 1 )  <new_line>
                    {  <new_line>
                        last ;  <new_line>
                    }  <new_line>
                    if ( $fill_direction == $fill_direction_top_left )  <new_line>
                    {  <new_line>
                        $top_left_open_column ++ ;  <new_line>
                    } elsif ( $fill_direction == $fill_direction_bottom_right )  <new_line>
                    {  <new_line>
                        $bottom_right_open_column -- ;  <new_line>
                    } elsif ( $fill_direction == $fill_direction_bottom_left )  <new_line>
                    {  <new_line>
                        $bottom_left_open_column ++ ;  <new_line>
                    } elsif ( $fill_direction == $fill_direction_top_right )  <new_line>
                    {  <new_line>
                        $top_right_open_column -- ;  <new_line>
                    }  <new_line>
                    $zero_if_not_remaining_item_number[ $item_number_at_min_or_max ] = 0 ;  <new_line>
                }  <new_line>
                if ( $number_of_items_remaining < 1 )  <new_line>
                {  <new_line>
                    last ;  <new_line>
                }  <new_line>
                if ( $top_left_open_column > $top_right_open_column )  <new_line>
                {  <new_line>
                    $top_row_number ++ ;  <new_line>
                    $top_left_open_column = 1 ;  <new_line>
                    $top_right_open_column = $number_of_columns ;  <new_line>
                }  <new_line>
                if ( $bottom_left_open_column > $bottom_right_open_column )  <new_line>
                {  <new_line>
                    $bottom_row_number -- ;  <new_line>
                    $bottom_left_open_column = 1 ;  <new_line>
                    $bottom_right_open_column = $number_of_columns ;  <new_line>
                }  <new_line>
                if ( $top_row_number == $bottom_row_number )  <new_line>
                {  <new_line>
                    if ( $top_left_open_column > $bottom_left_open_column )  <new_line>
                    {  <new_line>
                        $bottom_left_open_column = $top_left_open_column ;  <new_line>
                    }  <new_line>
                    if ( $top_left_open_column < $bottom_left_open_column )  <new_line>
                    {  <new_line>
                        $top_left_open_column = $bottom_left_open_column ;  <new_line>
                    }  <new_line>
                    if ( $top_right_open_column > $bottom_right_open_column )  <new_line>
                    {  <new_line>
                        $top_right_open_column = $bottom_right_open_column ;  <new_line>
                    }  <new_line>
                    if ( $top_right_open_column < $bottom_right_open_column )  <new_line>
                    {  <new_line>
                        $bottom_right_open_column = $top_right_open_column ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            $final_result = "" ;  <new_line>
            for ( $item_number = 1 ; $item_number <= $number_of_items ; $item_number ++ )  <new_line>
            {  <new_line>
                $row_number = $row_position_for_item_number[ $item_number ] ;  <new_line>
                $column_number = $column_position_for_item_number[ $item_number ] ;  <new_line>
                $final_result .= "row-" . $row_number . "-column-" . $column_number . " " ;  <new_line>
                $item_number_at_row_column{ $row_number . "" . $column_number } = $item_number ;  <new_line>
            }  <new_line>
            $final_result =~ s/ +$// ;  <new_line>
            $global_dashrep_replacement{ $operand_four } = $final_result ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; " . $number_of_items . " items , " . $number_of_columns . " columns , " . $number_of_rows . " rows , " . $number_of_items_in_bottom_row . " items in bottom row}}\n" ;  <new_line>
                $global_trace_log .= "{{trace; two-dimensionally sorted items}}\n" ;  <new_line>
                for ( $row_number = 1 ; $row_number <= $number_of_rows ; $row_number ++ )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{row " . $row_number . ":  " ;  <new_line>
                    for ( $column_number = 1 ; $column_number <= $number_of_columns ; $column_number ++ )  <new_line>
                    {  <new_line>
                        if ( ( $row_number < $number_of_rows ) || ( ( $row_number == $number_of_rows ) && ( $column_number <= $number_of_items_in_bottom_row ) ) )  <new_line>
                        {  <new_line>
                            $item_number = $item_number_at_row_column{ $row_number . "" . $column_number } ;  <new_line>
                            $global_trace_log .= "item " . $item_number . " (" . $up_direction_value_for_item_number[ $item_number ] . " " . $right_direction_value_for_item_number[ $item_number ] . ") " ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                    $global_trace_log .= "}}\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  get-current-time-in-epoch-seconds  <new_line>

        if ( $action_name eq "get-current-time-in-epoch-seconds" )  <new_line>
        {  <new_line>
            $epoch_seconds = time ;  <new_line>
            $action_result = sprintf( "%d" , $epoch_seconds ) ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  split-epoch-seconds-into-named-components  <new_line>
#  split-epoch-seconds-into-named-components-for-zero-meridian  <new_line>

        if ( ( $action_name eq "split-epoch-seconds-into-named-components" ) || ( $action_name eq "split-epoch-seconds-into-named-components-for-zero-meridian" ) )  <new_line>
        {  <new_line>
            if ( $operand_one !~ /^[\-0-9\.]+$/ )  <new_line>
            {  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , invalid operand: " . $operand_one . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            if ( $action_name eq "split-epoch-seconds-into-named-components" )  <new_line>
            {  <new_line>
                ( $second_time , $minute , $hour , $day_of_month , $month_number , $year , $weekday , $day_of_year , $extra_info ) = localtime( $operand_one ) ;  <new_line>
            } else  <new_line>
            {  <new_line>
                ( $second_time , $minute , $hour , $day_of_month , $month_number , $year , $weekday , $day_of_year , $extra_info ) = gmtime( $operand_one ) ;  <new_line>
            }  <new_line>
            $month_number ++ ;  <new_line>
            $year += 1900 ;  <new_line>
            $global_dashrep_replacement{ "time-second" } = sprintf( "%d" , $second_time ) ;  <new_line>
            $global_dashrep_replacement{ "time-minute" } = sprintf( "%d" , $minute ) ;  <new_line>
            $global_dashrep_replacement{ "time-hour" } = sprintf( "%d" , $hour ) ;  <new_line>
            $global_dashrep_replacement{ "time-day-of-month" } = sprintf( "%d" , $day_of_month ) ;  <new_line>
            $global_dashrep_replacement{ "time-month-number" } = sprintf( "%d" , $month_number ) ;  <new_line>
            $global_dashrep_replacement{ "time-year" } = sprintf( "%d" , $year ) ;  <new_line>
            $global_dashrep_replacement{ "time-day-of-week" } = sprintf( "%d" , $weekday ) ;  <new_line>
            $global_dashrep_replacement{ "time-day-of-year" } = sprintf( "%d" , $day_of_year ) ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  use-handler-with-each-word-in-phrase  <new_line>
#  use-handler-with-each-word-in-phrase-currently-at-character-position  <new_line>
#  <new_line>
#  Note about the action:  <new_line>
#    use-handler-with-each-word-in-phrase-currently-at-character-position  <new_line>
#  This action is intended for internal use only, so some of  <new_line>
#  its operands are not checked for validity.  <new_line>

        if ( ( $action_name eq "use-handler-with-each-word-in-phrase" ) || ( $action_name eq "use-handler-with-each-word-in-phrase-currently-at-character-position" ) )  <new_line>
        {  <new_line>
            $name_of_parameter_for_handler = "word-to-use-in-handler" ;  <new_line>
            $handler_phrase_name = $operand_one ;  <new_line>
            if ( not( exists( $global_dashrep_replacement{ $operand_two } ) ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; warning, for action " . $action_name . " , invalid operand: " . $operand_two . "}}\n" ;  <new_line>
                }  <new_line>
                next ;  <new_line>
            }  <new_line>
            if ( ( $action_name eq "use-handler-with-each-word-in-phrase" ) && ( ( $global_dashrep_replacement{ $operand_two } =~ /^ / ) || ( $global_dashrep_replacement{ $operand_two } =~ / $/ ) || ( $global_dashrep_replacement{ $operand_two } =~ /  / ) ) )  <new_line>
            {  <new_line>
                $list_of_words_as_text = $global_dashrep_replacement{ $operand_two } ;  <new_line>
                $list_of_words_as_text =~ s/[ \n][ \n\r]+/ /sg ;  <new_line>
                $list_of_words_as_text =~ s/^ //s ;  <new_line>
                $list_of_words_as_text =~ s/ $//s ;  <new_line>
                $global_dashrep_replacement{ $operand_two } = $list_of_words_as_text ;  <new_line>
            }  <new_line>
            $text_to_expand = " [-" . $handler_phrase_name . "-] " ;  <new_line>
            $current_character_position_number = 1 ;  <new_line>
            if ( $action_name eq "use-handler-with-each-word-in-phrase-currently-at-character-position" )  <new_line>
            {  <new_line>
                $current_character_position_number = $operand_three + 0 ;  <new_line>
            }  <new_line>
            $character_pointer_to_next_word_zero_based = 1 + index( $global_dashrep_replacement{ $operand_two } , " " , ( $current_character_position_number - 1 ) ) ;  <new_line>
            if ( $character_pointer_to_next_word_zero_based > 0 )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $name_of_parameter_for_handler } = substr( $global_dashrep_replacement{ $operand_two } , ( $current_character_position_number - 1 ) , ( $character_pointer_to_next_word_zero_based - $current_character_position_number ) ) ;  <new_line>
                $current_character_position_number = $character_pointer_to_next_word_zero_based + 1 ;  <new_line>
                $text_to_expand .= "[-use-handler-with-each-word-in-phrase-currently-at-character-position " . $operand_one . " " . $operand_two . " " . sprintf( "%d" , $current_character_position_number ) . "-] " ;  <new_line>
            } else  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ $name_of_parameter_for_handler } = substr( $global_dashrep_replacement{ $operand_two } , ( $current_character_position_number - 1 ) ) ;  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                if ( $action_name eq "use-handler-with-each-word-in-phrase" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; action " . $action_name . " creating code that will use handler " . $operand_one . " with each word in phrase " . $operand_two . "}}\n";  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $text_to_expand . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  trace-show  <new_line>

        if ( $action_name eq "trace-show" )  <new_line>
        {  <new_line>
            if ( ( $operand_one !~ /^[\-_]/ ) && ( $operand_one !~ /[\-_]$/ ) )  <new_line>
            {  <new_line>
                if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
                {  <new_line>
                    $value_of_operand_one = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                    if ( $value_of_operand_one =~ /[^ ]/s )  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; ******* " . $operand_one . " = " . $value_of_operand_one . " *******" . "}}\n";  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        $global_trace_log .= "{{trace; ******* " . $operand_one . " is empty *******" . "}}\n";  <new_line>
                    }  <new_line>
                } else  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; ******* " . $operand_one . " is not defined *******" . "}}\n";  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; ******* " . $operand_one . " does not look like a valid phrase name *******" . "}}\n";  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ "dashrep-debug-trace-log" } .= $global_trace_log ;  <new_line>
            $global_trace_log = "" ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  generate-phrase-usage-counts  <new_line>

       if ( $action_name eq "generate-phrase-usage-counts" )  <new_line>
       {  <new_line>
            $result_text = "" ;  <new_line>
            foreach $phrase_name ( keys( %global_replacement_count_for_item_name ) )  <new_line>
            {  <new_line>
                $replacement_count = $global_replacement_count_for_item_name{ $phrase_name } ;  <new_line>


# edited 2017may25  <new_line>
                if ( ( exists( $endless_loop_replacements_with_count{ sprintf( "%08d" , $replacement_count ) } ) ) && ( $endless_loop_replacements_with_count{ sprintf( "%08d" , $replacement_count ) } ne "" ) )  <new_line>


                {  <new_line>
                    $endless_loop_replacements_with_count{ sprintf( "%08d" , $replacement_count ) } .= "\n" ;  <new_line>
                }  <new_line>
                $endless_loop_replacements_with_count{ sprintf( "%08d" , $replacement_count ) } .= $phrase_name ;  <new_line>
            }  <new_line>
            foreach $replacement_count_text ( reverse( sort( keys( %endless_loop_replacements_with_count ) ) ) )  <new_line>
            {  <new_line>
                @list_of_phrase_names = sort( split( /\n/ , $endless_loop_replacements_with_count{ $replacement_count_text } ) ) ;  <new_line>
                foreach $phrase_name ( @list_of_phrase_names )  <new_line>
                {  <new_line>
                    $result_text .= $replacement_count_text . " " . $phrase_name  . "\n" ;  <new_line>
                }  <new_line>
            }  <new_line>
            $global_dashrep_replacement{ $operand_one } = $result_text ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the actions:  <new_line>
#  if-yes-begin  <new_line>
#  if-no-begin  <new_line>
#  <new_line>
#  This action recognizes the strings:  <new_line>
#  [-if-else-]  <new_line>
#  [-if-end-]  <new_line>

        if ( ( $action_name eq "if-yes-begin" ) || ( $action_name eq "if-no-begin" ) )  <new_line>
        {  <new_line>
            if ( $action_name eq "if-yes-begin" )  <new_line>
            {  <new_line>
                if ( $operand_one =~ /yes/i )  <new_line>
                {  <new_line>
                    $first_or_second = "first" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $first_or_second = "second" ;  <new_line>
                }  <new_line>
            } else  <new_line>
            {  <new_line>
                if ( $operand_one =~ /no/i )  <new_line>
                {  <new_line>
                    $first_or_second = "first" ;  <new_line>
                } else  <new_line>
                {  <new_line>
                    $first_or_second = "second" ;  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $text_end =~ /^(.*?)\[- *if-end *-\](.*)$/ )  <new_line>
            {  <new_line>
                $segment_that_might_include_else = $1 ;  <new_line>
                $remainder = $2 ;  <new_line>
                if ( $segment_that_might_include_else =~ /^(.*?)\[- *if-else *-\](.*)$/ )  <new_line>
                {  <new_line>
                    $segment_if_first = $1 ;  <new_line>
                    $segment_if_second = $2 ;  <new_line>
                    if ( $first_or_second eq "first" )  <new_line>
                    {  <new_line>
                        $text_end = $segment_if_first . " " . $remainder ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        $text_end = $segment_if_second . " " . $remainder ;  <new_line>
                    }  <new_line>
                } else  <new_line>
                {  <new_line>
                    if ( $first_or_second eq "first" )  <new_line>
                    {  <new_line>
                        $text_end = $segment_that_might_include_else . " " . $remainder ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        $text_end = " " . $remainder ;  <new_line>
                    }  <new_line>
                }  <new_line>
            }  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; handling action " . $action_name . " for case " . $first_or_second . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the INVALID actions:  <new_line>
#  [-if-else-]  <new_line>
#  [-if-end-]  <new_line>
#  <new_line>
#  These pseudo-actions should have been removed  <new_line>
#  by the actions "if-yes-begin" and "if-no-begin",  <new_line>
#  so those valid actions are missing.  <new_line>

        if ( ( $action_name eq "if-else" ) || ( $action_name eq "if-end" ) )  <new_line>
        {  <new_line>
            $action_result = " " . $action_name . " " ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; Warning: pseudo-action " . $action_name . " was encountered, which means that a matching if-yes-begin or if-no-begin action is missing" . "}}\n" ;  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  unique-value  <new_line>
#  <new_line>
#  This action can be changed to accomodate a  <new_line>
#  parallel-processing environment where the  <new_line>
#  code here would assign values from separate  <new_line>
#  blocks of numbers assigned to each  <new_line>
#  processor/process.  <new_line>

        if ( $action_name eq "unique-value" )  <new_line>
        {  <new_line>
            $global_unique_value ++ ;  <new_line>
            $action_result = sprintf( "%d" , $global_unique_value ) ;  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  insert-codeview-tags  <new_line>

        if ( $action_name eq "insert-codeview-tags" )  <new_line>
        {  <new_line>
            if ( not( exists( $action_name_exists{ "no-space" } ) ) || ( $action_name_exists{ "no-space" } ne "yes" ) )  <new_line>
            {  <new_line>
                @list_of_action_names = split( / / , $global_dashrep_text_list_of_phrase_names ) ;  <new_line>
                foreach $action_name ( @list_of_action_names )  <new_line>
                {  <new_line>
                    $action_name_exists{ $action_name } = "yes" ;  <new_line>
                }  <new_line>
            }  <new_line>
            if ( exists( $global_dashrep_replacement{ $operand_one } ) )  <new_line>
            {  <new_line>
                $string_in_phrase = $global_dashrep_replacement{ $operand_one } ;  <new_line>
                $string_in_phrase =~ s/\n/<dashrep_codeview_newline>/sg ;  <new_line>
                $string_in_phrase =~ s/=/<dashrep_codeview_equal_sign>/sg ;  <new_line>
                $parameter_level = 1 ;  <new_line>
                $odd_or_even_based_on_zero_or_one[ 0 ] = "even" ;  <new_line>
                $odd_or_even_based_on_zero_or_one[ 1 ] = "odd" ;  <new_line>
                $accumulated_text = "" ;  <new_line>
                $remaining_text = $string_in_phrase ;  <new_line>
                while ( $remaining_text =~ /^(.*?)((\[-)|(-\]))(.*)$/ )  <new_line>
                {  <new_line>
                    $prefix_text = $1 ;  <new_line>
                    $parameter_begin_or_end_string = $2 ;  <new_line>
                    $remaining_text = $5 ;  <new_line>
                    $accumulated_text = $accumulated_text . $prefix_text ;  <new_line>
                    if ( $parameter_begin_or_end_string eq "[-" )  <new_line>
                    {  <new_line>
                        if ( $parameter_level >= 1 )  <new_line>
                        {  <new_line>
                            $accumulated_text = $accumulated_text . "<dashrep_codeview_tag_param_" . $odd_or_even_based_on_zero_or_one[ $parameter_level % 2 ] . "_begin>" ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $accumulated_text = $accumulated_text . "<dashrep_codeview_tag_param_unmatched_begin>" ;  <new_line>
                        }  <new_line>
                        $parameter_level ++ ;  <new_line>
                    } elsif ( $parameter_begin_or_end_string eq "-]" )  <new_line>
                    {  <new_line>
                        $parameter_level -- ;  <new_line>
                        if ( $parameter_level >= 1 )  <new_line>
                        {  <new_line>
                            $accumulated_text = $accumulated_text . "<dashrep_codeview_tag_param_" . $odd_or_even_based_on_zero_or_one[ $parameter_level % 2 ] . "_end>" ;  <new_line>
                        } else  <new_line>
                        {  <new_line>
                            $accumulated_text = $accumulated_text . "<dashrep_codeview_tag_param_unmatched_end>" ;  <new_line>
                        }  <new_line>
                    }  <new_line>
                }  <new_line>
                $string_in_phrase = $accumulated_text . $remaining_text ;  <new_line>
                $accumulated_text = "" ;  <new_line>
                $remaining_text = $string_in_phrase ;  <new_line>
                while ( $remaining_text =~ /^(.*?)([^ <>]+-[^ <>]+)(([ <]).*)$/ )  <new_line>
                {  <new_line>
                    $prefix_text = $1 ;  <new_line>
                    $phrase_name = $2 ;  <new_line>
                    $remaining_text = $3 ;  <new_line>
                    if ( exists( $action_name_exists{ $phrase_name } ) && ( $action_name_exists{ $phrase_name } eq "yes" ) )  <new_line>
                    {  <new_line>
                        $phrase_type = "action" ;  <new_line>
                    } elsif ( exists( $global_dashrep_replacement{ $phrase_name } ) && ( $global_dashrep_replacement{ $phrase_name } ne "" ) )  <new_line>
                    {  <new_line>
                        $phrase_type = "phrase_defined" ;  <new_line>
                    } else  <new_line>
                    {  <new_line>
                        $phrase_type = "phrase" ;  <new_line>
                    }  <new_line>
                    $accumulated_text = $accumulated_text . $prefix_text . "<dashrep_codeview_tag_" . $phrase_type . "_begin>" . $phrase_name . "<dashrep_codeview_tag_" . $phrase_type . "_middle_1>" . $phrase_name . "<dashrep_codeview_tag_" . $phrase_type . "_middle_2>" . $phrase_name . "<dashrep_codeview_tag_" . $phrase_type . "_end>" ;  <new_line>
                }  <new_line>
                $string_in_phrase = $accumulated_text . $remaining_text ;  <new_line>
                $global_dashrep_replacement{ $operand_one } = $string_in_phrase ;  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; action " . $action_name . " inserted codeview tags into " . $operand_one . "}}\n";  <new_line>
                }  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  escape-from-dashrep  <new_line>

        if ( $action_name eq "escape-from-dashrep" )  <new_line>
        {  <new_line>
            $global_dashrep_replacement{ "dashrep-replacement-results-at-time-of-escape" } = $text_begin . $action_result . $text_end ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; action " . $action_name . " saved remaining text in phrase dashrep-replacement-results-at-time-of-escape, and exited from Dashrep engine" . "}}\n";  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            last ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Handle the action:  <new_line>
#  resume-after-escape-from-dashrep  <new_line>

        if ( $action_name eq "resume-after-escape-from-dashrep" )  <new_line>
        {  <new_line>
            $text_begin = "" ;  <new_line>
            if ( not( defined( $global_dashrep_replacement{ "dashrep-replacement-results-at-time-of-escape" } ) ) )  <new_line>
            {  <new_line>
                $global_dashrep_replacement{ "dashrep-replacement-results-at-time-of-escape" } = "" ;  <new_line>
            }  <new_line>
            $text_end = $global_dashrep_replacement{ "dashrep-replacement-results-at-time-of-escape" } ;  <new_line>
            $global_dashrep_replacement{ "dashrep-replacement-results-at-time-of-escape" } = "" ;  <new_line>
            if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
            {  <new_line>
                $global_trace_log .= "{{trace; action " . $action_name . " started expanding text in phrase dashrep-replacement-results-at-time-of-escape" . "}}\n";  <new_line>
            }  <new_line>
#  end of action code  <new_line>
            $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  If the word "file" or "files" or "folder" or  <new_line>
#  "folders" appears in the action name,  <new_line>
#  and if the action is recognized as a file-related  <new_line>
#  action, execute the action.  <new_line>

        if ( $action_name =~ /((file)|(folder))/ )  <new_line>
        {  <new_line>
            if ( ( $action_name eq "copy-from-phrase-append-to-file" ) || ( $action_name eq "copy-from-file-to-phrase" ) || ( $action_name eq "copy-append-file-to-file" ) || ( $action_name eq "generate-list-of-files-in-current-read-directory" ) || ( $action_name eq "generate-list-of-folders-in-current-read-directory" ) || ( $action_name eq "yes-or-no-file-exists" ) || ( $action_name eq "yes-or-no-folder-exists" ) || ( $action_name eq "size-of-file" ) || ( $action_name eq "modification-time-of-file" ) || ( $action_name eq "set-file-permission-public-read" ) || ( $action_name eq "create-empty-file" ) || ( $action_name eq "create-empty-sub-folder" ) || ( $action_name eq "rename-file" ) || ( $action_name eq "delete-file" ) || ( $action_name eq "find-line-in-file-that-begins-with-text" ) || ( $action_name eq "find-lines-in-file-that-begin-with-any-listed-word" ) || ( $action_name eq "find-lines-in-file-that-begin-with-any-two-words-listed" ) || ( $action_name eq "write-all-dashrep-definitions-to-file" ) || ( $action_name eq "write-dashrep-definitions-listed-in-phrase-to-file" ) || ( $action_name eq "get-definitions-from-file" ) || ( $action_name eq "linewise-translate-from-file-to-file" ) || ( $action_name eq "linewise-translate-parameters-only-from-file-to-file" ) || ( $action_name eq "linewise-translate-phrases-only-from-file-to-file" ) || ( $action_name eq "linewise-translate-special-phrases-only-from-file-to-file" ) || ( $action_name eq "copy-from-columns-in-file-to-named-phrases" ) || ( $action_name eq "copy-from-columns-in-file-to-column-lists" ) || ( $action_name eq "gather-tagged-info-from-file" ) || ( $action_name eq "write-gathered-listed-items-to-end-of-file" ) || ( $action_name eq "gather-from-tagged-file-one-entry" ) || ( $action_name eq "linewise-read-from-file-and-use-handler" ) )  <new_line>
            {  <new_line>
                if ( $global_dashrep_replacement{ "dashrep-action-trace-on-yes-or-no" } eq "yes" )  <new_line>
                {  <new_line>
                    $global_trace_log .= "{{trace; file-related action encountered: " . $action_name . " " . $operands_all . "}}\n" ;  <new_line>
                }  <new_line>
                $global_action_name = $action_name ;  <new_line>
                $global_operand_one = $operand_one ;  <new_line>
                $global_operand_two = $operand_two ;  <new_line>
                $global_operand_three = $operand_three ;  <new_line>
                $global_operand_four = $operand_four ;  <new_line>
                $global_operand_five = $operand_five ;  <new_line>
                $global_operands_all = $operands_all ;  <new_line>
                &dashrep_file_actions( ) ;  <new_line>
                $action_result = $global_action_result ;  <new_line>
                $replacement_text = $text_begin . $action_result . $text_end ;  <new_line>
                next ;  <new_line>
            }  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Make the endless loop counter value available  <new_line>
#  -- on a read-only basis -- for debugging.  <new_line>

        if ( $action_name eq "dashrep-endless-loop-count" )  <new_line>
        {  <new_line>
            $replacement_text = $text_begin . $global_endless_loop_counter . $text_end ;  <new_line>
            next ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  If the parameter content has not been  <new_line>
#  recognized, simply remove the "[-" and "-]"  <new_line>
#  strings.  <new_line>

        $replacement_text = $text_begin . " " . $text_parameter_content . " " . $text_end ;  <new_line>
        if ( ( $global_dashrep_replacement{ "dashrep-warning-trace-on-yes-or-no" } eq "yes" ) && ( $action_name =~ /[^ ]/ ) )  <new_line>
        {  <new_line>
            $global_trace_log .= "{{trace; warning, action not recognized: " . $action_name . "}}\n";  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Avoid an endless loop (caused by a replacement  <new_line>
#  containing, at some level, itself).  <new_line>

        $global_endless_loop_counter ++ ;  <new_line>
        $global_replacement_count_for_item_name{ "unknown action" } ++ ;  <new_line>
        if ( $global_endless_loop_counter > $global_endless_loop_counter_limit )  <new_line>
        {  <new_line>
            &handle_endless_loop_encountered( ) ;  <new_line>
#  remove-from-cpan-version-begin  <new_line>
            warn "Warning: The dashrep_expand_parameters subroutine has encountered an endless loop." . "\n" . "Stopped" ;  <new_line>
#  remove-from-cpan-version-end  <new_line>
#  uncomment-for-cpan-version-begin  <new_line>
#            carp "Warning: The dashrep_expand_parameters subroutine has encountered an endless loop." . "\n" . "Stopped" ;  <new_line>
#  uncomment-for-cpan-version-end  <new_line>
            return 0 ;  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Check if time limit exceeded.  <new_line>

        $global_interval_count_for_time_limit_check ++ ;  <new_line>
        if ( $global_interval_count_for_time_limit_check > 1000 )  <new_line>
        {  <new_line>
            $global_interval_count_for_time_limit_check = 0 ;  <new_line>
            $elapsed_time = time - $global_starting_time ;  <new_line>
            if ( $elapsed_time > $global_time_limit )  <new_line>
            {  <new_line>
#  remove-from-cpan-version-begin  <new_line>
                warn "Warning: The dashrep_expand_parameters subroutine has exceeded the time limit." . "\n" . "Stopped" ;  <new_line>
#  remove-from-cpan-version-end  <new_line>
#  uncomment-for-cpan-version-begin  <new_line>
#                carp "Warning: The dashrep_expand_parameters subroutine has exceeded the time limit." . "\n" . "Stopped" ;  <new_line>
#  uncomment-for-cpan-version-end  <new_line>
                return 0 ;  <new_line>
            }  <new_line>
        }  <new_line>


#***********************************************  <new_line>
#  Repeat the loop that repeats until no more  <new_line>
#  parameters remain.  <new_line>

    }  <new_line>


#***********************************************  <new_line>
#  Make the logged debugging (trace) information  <new_line>
#  available.  <new_line>

    $global_dashrep_replacement{ "dashrep-debug-trace-log" } .= $global_trace_log ;  <new_line>
    $global_trace_log = "" ;  <new_line>


#***********************************************  <new_line>
#  Return the revised text.  <new_line>

    return $replacement_text ;  <new_line>


#***********************************************  <new_line>
#  End of subroutine.  <new_line>

}  <new_line>
